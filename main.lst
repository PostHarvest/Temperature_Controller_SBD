CCS PCH C Compiler, Version 5.015, 5967               12-Mar-18 11:40

               Filename:   D:\truc\Local Disk\du lieu\BSD\BSD datasheet\MAX31855\Max31855-18F248 - controller - NewPan\main.lst

               ROM used:   9920 bytes (61%)
                           Largest free fragment is 6460
               RAM used:   68 (9%) at main() level
                           136 (18%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   1E7E
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   033C
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            EX_CAN.C                             //// 
.................... ////                                                                 //// 
.................... //// Example of CCS's CAN library, using the PIC18Fxx8.  This        //// 
.................... //// example was tested using MCP250xxx CAN Developer's Kit.         //// 
.................... ////                                                                 //// 
.................... //// Connect pin B2 (CANTX) to the CANTX pin on the open NODE A of   //// 
.................... //// the developer's kit, and connect pin B3 (CANRX) to the CANRX    //// 
.................... //// pin on the open NODE A.                                         //// 
.................... ////                                                                 //// 
.................... //// NODE B has an MCP250xxx which sends and responds certan canned  //// 
.................... //// messages.  For example, hitting one of the GPX buttons on       //// 
.................... //// the development kit causes the MCP250xxx to send a 2 byte       //// 
.................... //// message with an ID of 0x290.  After pressing one of those       //// 
.................... //// buttons with this firmware you should see this message          //// 
.................... //// displayed over RS232.                                           //// 
.................... ////                                                                 //// 
.................... //// NODE B also responds to certain CAN messages.  If you send      //// 
.................... //// a request (RTR bit set) with an ID of 0x18 then NODE B will     //// 
.................... //// respond with an 8-byte message containing certain readings.     //// 
.................... //// This firmware sends this request every 2 seconds, which NODE B  //// 
.................... //// responds.                                                       //// 
.................... ////                                                                 //// 
.................... //// If you install Microchip's CANKing software and use the         //// 
.................... //// MCP250xxx , you can see all the CAN traffic and validate all    //// 
.................... //// experiments.                                                    //// 
.................... ////                                                                 //// 
.................... //// For more documentation on the CCS CAN library, see can-18xxx8.c //// 
.................... ////                                                                 //// 
.................... ////  Jumpers:                                                       //// 
.................... ////     PCM,PCH    pin C7 to RS232 RX, pin C6 to RS232 TX           //// 
.................... ////                                                                 //// 
.................... ////  This example will work with the PCM and PCH compilers.         //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#include <18F248.h> 
.................... #include <18F2480.h> 
.................... //////////// Standard Header file for the PIC18F2480 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2480 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  ADDLW  AE
009E:  MOVWF  FF6
00A0:  MOVLW  00
00A2:  ADDWFC FF7,F
00A4:  TBLRD*+
00A6:  MOVF   FF5,W
00A8:  BTFSC  0D.7
00AA:  BSF    FF2.7
00AC:  RETURN 0
00AE:  DATA 00,00
00B0:  DATA 27,00
00B2:  DATA 4F,00
00B4:  DATA 76,00
00B6:  DATA 9D,00
00B8:  DATA C5,00
00BA:  DATA EC,00
00BC:  DATA 13,01
00BE:  DATA 3A,01
00C0:  DATA 61,01
00C2:  DATA 88,01
00C4:  DATA AF,01
00C6:  DATA D6,01
00C8:  DATA FC,01
00CA:  DATA 23,02
00CC:  DATA 4A,02
00CE:  DATA 70,02
00D0:  DATA 97,02
00D2:  DATA BD,02
00D4:  DATA E3,02
00D6:  DATA 0A,03
00D8:  DATA 30,03
00DA:  DATA 56,03
00DC:  DATA 7C,03
00DE:  DATA A2,03
00E0:  DATA C8,03
00E2:  DATA EE,03
00E4:  DATA 13,04
00E6:  DATA 39,04
00E8:  DATA 5F,04
00EA:  DATA 84,04
00EC:  DATA AA,04
00EE:  DATA CF,04
00F0:  DATA F4,04
00F2:  DATA 19,05
00F4:  DATA 3F,05
00F6:  DATA 64,05
00F8:  DATA 89,05
00FA:  DATA AD,05
00FC:  DATA D2,05
00FE:  DATA F7,05
0100:  DATA 1C,06
0102:  DATA 40,06
0104:  DATA 65,06
0106:  DATA 89,06
0108:  DATA AD,06
010A:  DATA D1,06
010C:  DATA F6,06
010E:  DATA 1A,07
0110:  DATA 3E,07
0112:  DATA 61,07
0114:  DATA 85,07
0116:  DATA A9,07
0118:  DATA CC,07
011A:  DATA F0,07
011C:  DATA 13,08
011E:  DATA 37,08
0120:  DATA 5A,08
0122:  DATA 7D,08
0124:  DATA A0,08
0126:  DATA C3,08
0128:  DATA E6,08
012A:  DATA 08,09
012C:  DATA 2B,09
012E:  DATA 4E,09
0130:  DATA 70,09
0132:  DATA 92,09
0134:  DATA B5,09
0136:  DATA D7,09
0138:  DATA F9,09
013A:  DATA 1B,0A
013C:  DATA 3C,0A
013E:  DATA 5E,0A
0140:  DATA 80,0A
0142:  DATA A1,0A
0144:  DATA C3,0A
0146:  DATA E4,0A
0148:  DATA 05,0B
014A:  DATA 26,0B
014C:  DATA 47,0B
014E:  DATA 68,0B
0150:  DATA 89,0B
0152:  DATA AA,0B
0154:  DATA CA,0B
0156:  DATA EA,0B
0158:  DATA 0B,0C
015A:  DATA 2B,0C
015C:  DATA 4B,0C
015E:  DATA 6B,0C
0160:  DATA 8B,0C
0162:  DATA AB,0C
0164:  DATA CA,0C
0166:  DATA EA,0C
0168:  DATA 09,0D
016A:  DATA 28,0D
016C:  DATA 48,0D
016E:  DATA 67,0D
0170:  DATA 86,0D
0172:  DATA A4,0D
0174:  DATA C3,0D
0176:  DATA E2,0D
0178:  DATA 00,0E
017A:  DATA 1E,0E
017C:  DATA 3D,0E
017E:  DATA 5B,0E
0180:  DATA 79,0E
0182:  DATA 96,0E
0184:  DATA B4,0E
0186:  DATA D2,0E
0188:  DATA EF,0E
018A:  DATA 0C,0F
018C:  DATA 2A,0F
018E:  DATA 47,0F
0190:  DATA 63,0F
0192:  DATA 80,0F
0194:  DATA 9D,0F
0196:  DATA B9,0F
0198:  DATA D6,0F
019A:  DATA F2,0F
019C:  DATA 0E,10
019E:  DATA 2A,10
01A0:  DATA 46,10
01A2:  DATA 62,10
01A4:  DATA 7D,10
01A6:  DATA 99,10
01A8:  DATA B4,10
01AA:  DATA CF,10
01AC:  DATA EA,10
01AE:  DATA 05,11
01B0:  DATA 20,11
01B2:  DATA 3B,11
01B4:  DATA 55,11
01B6:  DATA 6F,11
01B8:  DATA 8A,11
01BA:  DATA A4,11
01BC:  DATA BE,11
01BE:  DATA D7,11
01C0:  DATA F1,11
01C2:  DATA 0A,12
01C4:  DATA 24,12
01C6:  DATA 3D,12
01C8:  DATA 56,12
01CA:  DATA 6F,12
01CC:  DATA 88,12
01CE:  DATA A0,12
01D0:  DATA B9,12
01D2:  DATA D1,12
01D4:  DATA E9,12
01D6:  DATA 01,13
01D8:  DATA 19,13
01DA:  MOVFF  FF2,0D
01DE:  BCF    FF2.7
01E0:  ADDLW  F2
01E2:  MOVWF  FF6
01E4:  MOVLW  01
01E6:  ADDWFC FF7,F
01E8:  TBLRD*+
01EA:  MOVF   FF5,W
01EC:  BTFSC  0D.7
01EE:  BSF    FF2.7
01F0:  RETURN 0
01F2:  DATA 00,00
01F4:  DATA 27,00
01F6:  DATA 4F,00
01F8:  DATA 77,00
01FA:  DATA 9E,00
01FC:  DATA C6,00
01FE:  DATA EE,00
0200:  DATA 15,01
0202:  DATA 3D,01
0204:  DATA 65,01
0206:  DATA 8D,01
0208:  DATA B5,01
020A:  DATA DD,01
020C:  DATA 05,02
020E:  DATA 2D,02
0210:  DATA 55,02
0212:  DATA 7D,02
0214:  DATA A5,02
0216:  DATA CE,02
0218:  DATA F6,02
021A:  DATA 1E,03
021C:  DATA 46,03
021E:  DATA 6F,03
0220:  DATA 97,03
0222:  DATA C0,03
0224:  DATA E8,03
0226:  DATA 11,04
0228:  DATA 39,04
022A:  DATA 62,04
022C:  DATA 8B,04
022E:  DATA B3,04
0230:  DATA DC,04
0232:  DATA 05,05
0234:  DATA 2E,05
0236:  DATA 56,05
0238:  DATA 7F,05
023A:  DATA A8,05
023C:  DATA D1,05
023E:  DATA FA,05
0240:  DATA 23,06
0242:  DATA 4C,06
0244:  DATA 75,06
0246:  DATA 9E,06
0248:  DATA C7,06
024A:  DATA F0,06
024C:  DATA 19,07
024E:  DATA 42,07
0250:  DATA 6B,07
0252:  DATA 95,07
0254:  DATA BE,07
0256:  DATA E7,07
0258:  DATA 10,08
025A:  DATA 3A,08
025C:  DATA 63,08
025E:  DATA 8C,08
0260:  DATA B6,08
0262:  DATA DF,08
0264:  DATA 08,09
0266:  DATA 32,09
0268:  DATA 5B,09
026A:  DATA 84,09
026C:  DATA AE,09
026E:  DATA D7,09
0270:  DATA 01,0A
0272:  DATA 2A,0A
0274:  DATA 54,0A
0276:  DATA 7D,0A
0278:  DATA A7,0A
027A:  DATA D0,0A
027C:  DATA FA,0A
027E:  DATA 23,0B
0280:  DATA 4D,0B
0282:  DATA 76,0B
0284:  DATA A0,0B
0286:  DATA C9,0B
0288:  DATA F3,0B
028A:  DATA 1C,0C
028C:  DATA 46,0C
028E:  DATA 70,0C
0290:  DATA 99,0C
0292:  DATA C3,0C
0294:  DATA EC,0C
0296:  DATA 16,0D
0298:  DATA 3F,0D
029A:  DATA 69,0D
029C:  DATA 92,0D
029E:  DATA BC,0D
02A0:  DATA E5,0D
02A2:  DATA 0F,0E
02A4:  DATA 38,0E
02A6:  DATA 62,0E
02A8:  DATA 8B,0E
02AA:  DATA B5,0E
02AC:  DATA DE,0E
02AE:  DATA 08,0F
02B0:  DATA 31,0F
02B2:  DATA 5B,0F
02B4:  DATA 84,0F
02B6:  DATA AD,0F
02B8:  DATA D7,0F
02BA:  DATA 00,10
02BC:  DATA 2A,10
02BE:  DATA 53,10
02C0:  DATA 7C,10
02C2:  DATA A6,10
02C4:  DATA CF,10
02C6:  DATA F8,10
02C8:  DATA 21,11
02CA:  DATA 4B,11
02CC:  DATA 74,11
02CE:  DATA 9D,11
02D0:  DATA C6,11
02D2:  DATA EF,11
02D4:  DATA 19,12
02D6:  DATA 42,12
02D8:  DATA 6B,12
02DA:  DATA 94,12
02DC:  DATA BD,12
02DE:  DATA E6,12
02E0:  DATA 0F,13
02E2:  DATA 38,13
02E4:  DATA 61,13
02E6:  DATA 8A,13
02E8:  DATA B3,13
02EA:  DATA DC,13
02EC:  DATA 04,14
02EE:  DATA 2D,14
02F0:  DATA 56,14
02F2:  DATA 7F,14
02F4:  DATA A8,14
02F6:  DATA D0,14
02F8:  DATA F9,14
02FA:  DATA 22,15
02FC:  DATA 4A,15
02FE:  DATA 73,15
0300:  DATA 9C,15
0302:  DATA C4,15
0304:  DATA ED,15
0306:  DATA 15,16
0308:  DATA 3E,16
030A:  DATA 67,16
030C:  DATA 8F,16
030E:  DATA B7,16
0310:  DATA E0,16
0312:  DATA 08,17
0314:  DATA 31,17
0316:  DATA 59,17
0318:  DATA 81,17
031A:  DATA AA,17
031C:  DATA D2,17
031E:  MOVFF  FF2,0D
0322:  BCF    FF2.7
0324:  CLRF   FF7
0326:  ADDLW  38
0328:  MOVWF  FF6
032A:  MOVLW  03
032C:  ADDWFC FF7,F
032E:  TBLRD*+
0330:  MOVF   FF5,W
0332:  BTFSC  0D.7
0334:  BSF    FF2.7
0336:  RETURN 0
0338:  DATA 28,0C
033A:  DATA 01,06
*
0348:  DATA 0D,0A
034A:  DATA 0D,0A
034C:  DATA 43,43
034E:  DATA 53,20
0350:  DATA 43,41
0352:  DATA 4E,20
0354:  DATA 54,52
0356:  DATA 41,4E
0358:  DATA 53,46
035A:  DATA 45,52
035C:  DATA 20,42
035E:  DATA 4D,45
0360:  DATA 32,38
0362:  DATA 30,20
0364:  DATA 44,41
0366:  DATA 54,41
0368:  DATA 0D,0A
036A:  DATA 00,00
036C:  DATA 0D,0A
036E:  DATA 52,75
0370:  DATA 6E,6E
0372:  DATA 69,6E
0374:  DATA 67,2E
0376:  DATA 2E,2E
0378:  DATA 00,00
037A:  DATA 0D,0A
037C:  DATA 6C,6F
037E:  DATA 77,3D
0380:  DATA 25,75
0382:  DATA 00,00
0384:  DATA 0D,0A
0386:  DATA 68,69
0388:  DATA 67,68
038A:  DATA 3D,25
038C:  DATA 75,00
038E:  DATA 0D,0A
0390:  DATA 53,50
0392:  DATA 49,56
0394:  DATA 41,4C
0396:  DATA 33,20
0398:  DATA 3D,20
039A:  DATA 25,58
039C:  DATA 20,53
039E:  DATA 50,49
03A0:  DATA 56,41
03A2:  DATA 4C,32
03A4:  DATA 20,3D
03A6:  DATA 20,25
03A8:  DATA 58,20
03AA:  DATA 53,50
03AC:  DATA 49,56
03AE:  DATA 41,4C
03B0:  DATA 31,20
03B2:  DATA 3D,20
03B4:  DATA 25,58
03B6:  DATA 20,53
03B8:  DATA 50,49
03BA:  DATA 56,41
03BC:  DATA 4C,30
03BE:  DATA 20,3D
03C0:  DATA 20,25
03C2:  DATA 58,20
03C4:  DATA 00,00
03C6:  DATA 0D,50
03C8:  DATA 72,65
03CA:  DATA 20,46
03CC:  DATA 69,6C
03CE:  DATA 74,65
03D0:  DATA 72,20
03D2:  DATA 3D,20
03D4:  DATA 25,66
03D6:  DATA 20,4C
03D8:  DATA 69,6E
03DA:  DATA 65,61
03DC:  DATA 72,69
03DE:  DATA 7A,65
03E0:  DATA 64,20
03E2:  DATA 3D,20
03E4:  DATA 25,66
03E6:  DATA 20,00
03E8:  DATA 49,44
03EA:  DATA 3A,30
03EC:  DATA 78,32
03EE:  DATA 39,00
03F0:  DATA 0D,0A
03F2:  DATA 47,4F
03F4:  DATA 54,3A
03F6:  DATA 20,42
03F8:  DATA 55,46
03FA:  DATA 46,3D
03FC:  DATA 25,55
03FE:  DATA 20,49
0400:  DATA 44,3D
0402:  DATA 25,4C
0404:  DATA 55,20
0406:  DATA 4C,45
0408:  DATA 4E,3D
040A:  DATA 25,55
040C:  DATA 20,4F
040E:  DATA 56,46
0410:  DATA 3D,25
0412:  DATA 55,20
0414:  DATA 00,00
0416:  DATA 46,49
0418:  DATA 4C,54
041A:  DATA 3D,25
041C:  DATA 55,20
041E:  DATA 52,54
0420:  DATA 52,3D
0422:  DATA 25,55
0424:  DATA 20,45
0426:  DATA 58,54
0428:  DATA 3D,25
042A:  DATA 55,20
042C:  DATA 49,4E
042E:  DATA 56,3D
0430:  DATA 25,55
0432:  DATA 00,00
0434:  DATA 0D,0A
0436:  DATA 20,20
0438:  DATA 20,20
043A:  DATA 44,41
043C:  DATA 54,41
043E:  DATA 20,3D
0440:  DATA 20,00
0442:  DATA 0D,0A
0444:  DATA 46,41
0446:  DATA 49,4C
0448:  DATA 20,6F
044A:  DATA 6E,20
044C:  DATA 47,45
044E:  DATA 54,44
0450:  DATA 0D,0A
0452:  DATA 00,00
0454:  DATA 0D,0A
0456:  DATA 50,55
0458:  DATA 54,20
045A:  DATA 25,55
045C:  DATA 3A,20
045E:  DATA 49,44
0460:  DATA 3D,25
0462:  DATA 4C,55
0464:  DATA 20,4C
0466:  DATA 45,4E
0468:  DATA 3D,25
046A:  DATA 55,20
046C:  DATA 00,00
046E:  DATA 50,52
0470:  DATA 49,3D
0472:  DATA 25,55
0474:  DATA 20,45
0476:  DATA 58,54
0478:  DATA 3D,25
047A:  DATA 55,20
047C:  DATA 52,54
047E:  DATA 52,3D
0480:  DATA 25,55
0482:  DATA 0D,0A
0484:  DATA 20,20
0486:  DATA 20,44
0488:  DATA 41,54
048A:  DATA 41,20
048C:  DATA 3D,20
048E:  DATA 00,00
0490:  DATA 0D,0A
0492:  DATA 46,41
0494:  DATA 49,4C
0496:  DATA 20,6F
0498:  DATA 6E,20
049A:  DATA 50,55
049C:  DATA 54,44
049E:  DATA 0D,0A
04A0:  DATA 00,00
04A2:  TBLRD*+
04A4:  MOVF   FF5,F
04A6:  BZ    04C2
04A8:  MOVFF  FF6,52
04AC:  MOVFF  FF7,53
04B0:  MOVF   FF5,W
04B2:  BTFSS  F9E.4
04B4:  BRA    04B2
04B6:  MOVWF  FAD
04B8:  MOVFF  52,FF6
04BC:  MOVFF  53,FF7
04C0:  BRA    04A2
04C2:  RETURN 0
*
0832:  MOVF   59,W
0834:  CLRF   01
0836:  SUBWF  58,W
0838:  BC    0840
083A:  MOVFF  58,00
083E:  BRA    0858
0840:  CLRF   00
0842:  MOVLW  08
0844:  MOVWF  5A
0846:  RLCF   58,F
0848:  RLCF   00,F
084A:  MOVF   59,W
084C:  SUBWF  00,W
084E:  BTFSC  FD8.0
0850:  MOVWF  00
0852:  RLCF   01,F
0854:  DECFSZ 5A,F
0856:  BRA    0846
0858:  RETURN 0
085A:  TBLRD*+
085C:  MOVFF  FF6,57
0860:  MOVFF  FF7,58
0864:  MOVF   FF5,W
0866:  BTFSS  F9E.4
0868:  BRA    0866
086A:  MOVWF  FAD
086C:  MOVFF  57,FF6
0870:  MOVFF  58,FF7
0874:  DECFSZ 56,F
0876:  BRA    085A
0878:  RETURN 0
087A:  MOVF   01,W
087C:  MOVFF  56,58
0880:  MOVLW  64
0882:  MOVWF  59
0884:  RCALL  0832
0886:  MOVFF  00,56
088A:  MOVF   01,W
088C:  MOVLW  30
088E:  BNZ   089E
0890:  BTFSS  57.1
0892:  BRA    08AE
0894:  BTFSC  57.3
0896:  BRA    08AE
0898:  BTFSC  57.4
089A:  MOVLW  20
089C:  BRA    08A4
089E:  BCF    57.3
08A0:  BCF    57.4
08A2:  BSF    57.0
08A4:  ADDWF  01,F
08A6:  MOVF   01,W
08A8:  BTFSS  F9E.4
08AA:  BRA    08A8
08AC:  MOVWF  FAD
08AE:  MOVFF  56,58
08B2:  MOVLW  0A
08B4:  MOVWF  59
08B6:  RCALL  0832
08B8:  MOVFF  00,56
08BC:  MOVF   01,W
08BE:  MOVLW  30
08C0:  BNZ   08CE
08C2:  BTFSC  57.3
08C4:  BRA    08D8
08C6:  BTFSS  57.0
08C8:  BRA    08D8
08CA:  BTFSC  57.4
08CC:  MOVLW  20
08CE:  ADDWF  01,F
08D0:  MOVF   01,W
08D2:  BTFSS  F9E.4
08D4:  BRA    08D2
08D6:  MOVWF  FAD
08D8:  MOVLW  30
08DA:  ADDWF  56,F
08DC:  MOVF   56,W
08DE:  BTFSS  F9E.4
08E0:  BRA    08DE
08E2:  MOVWF  FAD
08E4:  RETURN 0
*
0994:  MOVLW  8E
0996:  MOVWF  00
0998:  MOVFF  7A,01
099C:  MOVFF  79,02
09A0:  CLRF   03
09A2:  MOVF   01,F
09A4:  BNZ   09B8
09A6:  MOVFF  02,01
09AA:  CLRF   02
09AC:  MOVLW  08
09AE:  SUBWF  00,F
09B0:  MOVF   01,F
09B2:  BNZ   09B8
09B4:  CLRF   00
09B6:  BRA    09C8
09B8:  BCF    FD8.0
09BA:  BTFSC  01.7
09BC:  BRA    09C6
09BE:  RLCF   02,F
09C0:  RLCF   01,F
09C2:  DECF   00,F
09C4:  BRA    09B8
09C6:  BCF    01.7
09C8:  RETURN 0
09CA:  BTFSC  54.7
09CC:  BRA    09EE
09CE:  MOVLW  0F
09D0:  MOVWF  00
09D2:  SWAPF  53,W
09D4:  ANDWF  00,F
09D6:  MOVLW  0A
09D8:  SUBWF  00,W
09DA:  BC    09E2
09DC:  MOVLW  30
09DE:  ADDWF  00,F
09E0:  BRA    09E6
09E2:  MOVF   54,W
09E4:  ADDWF  00,F
09E6:  MOVF   00,W
09E8:  BTFSS  F9E.4
09EA:  BRA    09E8
09EC:  MOVWF  FAD
09EE:  MOVLW  0F
09F0:  ANDWF  53,F
09F2:  MOVLW  0A
09F4:  SUBWF  53,W
09F6:  BC    09FC
09F8:  MOVLW  30
09FA:  BRA    0A00
09FC:  BCF    54.7
09FE:  MOVF   54,W
0A00:  ADDWF  53,F
0A02:  MOVF   53,W
0A04:  BTFSS  F9E.4
0A06:  BRA    0A04
0A08:  MOVWF  FAD
0A0A:  RETURN 0
*
0A7A:  MOVF   x79,W
0A7C:  BTFSC  FD8.2
0A7E:  BRA    0BCA
0A80:  MOVWF  x85
0A82:  MOVF   x7D,W
0A84:  BTFSC  FD8.2
0A86:  BRA    0BCA
0A88:  SUBWF  x85,F
0A8A:  BNC   0A96
0A8C:  MOVLW  7F
0A8E:  ADDWF  x85,F
0A90:  BTFSC  FD8.0
0A92:  BRA    0BCA
0A94:  BRA    0AA2
0A96:  MOVLW  81
0A98:  SUBWF  x85,F
0A9A:  BTFSS  FD8.0
0A9C:  BRA    0BCA
0A9E:  BTFSC  FD8.2
0AA0:  BRA    0BCA
0AA2:  MOVFF  85,00
0AA6:  CLRF   01
0AA8:  CLRF   02
0AAA:  CLRF   03
0AAC:  CLRF   x84
0AAE:  MOVFF  7A,83
0AB2:  BSF    x83.7
0AB4:  MOVFF  7B,82
0AB8:  MOVFF  7C,81
0ABC:  MOVLW  19
0ABE:  MOVWF  x85
0AC0:  MOVF   x80,W
0AC2:  SUBWF  x81,F
0AC4:  BC    0AE0
0AC6:  MOVLW  01
0AC8:  SUBWF  x82,F
0ACA:  BC    0AE0
0ACC:  SUBWF  x83,F
0ACE:  BC    0AE0
0AD0:  SUBWF  x84,F
0AD2:  BC    0AE0
0AD4:  INCF   x84,F
0AD6:  INCF   x83,F
0AD8:  INCF   x82,F
0ADA:  MOVF   x80,W
0ADC:  ADDWF  x81,F
0ADE:  BRA    0B30
0AE0:  MOVF   x7F,W
0AE2:  SUBWF  x82,F
0AE4:  BC    0B0A
0AE6:  MOVLW  01
0AE8:  SUBWF  x83,F
0AEA:  BC    0B0A
0AEC:  SUBWF  x84,F
0AEE:  BC    0B0A
0AF0:  INCF   x84,F
0AF2:  INCF   x83,F
0AF4:  MOVF   x7F,W
0AF6:  ADDWF  x82,F
0AF8:  MOVF   x80,W
0AFA:  ADDWF  x81,F
0AFC:  BNC   0B30
0AFE:  INCF   x82,F
0B00:  BNZ   0B30
0B02:  INCF   x83,F
0B04:  BNZ   0B30
0B06:  INCF   x84,F
0B08:  BRA    0B30
0B0A:  MOVF   x7E,W
0B0C:  IORLW  80
0B0E:  SUBWF  x83,F
0B10:  BC    0B2E
0B12:  MOVLW  01
0B14:  SUBWF  x84,F
0B16:  BC    0B2E
0B18:  INCF   x84,F
0B1A:  MOVF   x7E,W
0B1C:  IORLW  80
0B1E:  ADDWF  x83,F
0B20:  MOVF   x7F,W
0B22:  ADDWF  x82,F
0B24:  BNC   0AF8
0B26:  INCF   x83,F
0B28:  BNZ   0AF8
0B2A:  INCF   x84,F
0B2C:  BRA    0AF8
0B2E:  BSF    03.0
0B30:  DECFSZ x85,F
0B32:  BRA    0B36
0B34:  BRA    0B4C
0B36:  BCF    FD8.0
0B38:  RLCF   x81,F
0B3A:  RLCF   x82,F
0B3C:  RLCF   x83,F
0B3E:  RLCF   x84,F
0B40:  BCF    FD8.0
0B42:  RLCF   03,F
0B44:  RLCF   02,F
0B46:  RLCF   01,F
0B48:  RLCF   x86,F
0B4A:  BRA    0AC0
0B4C:  BTFSS  x86.0
0B4E:  BRA    0B5C
0B50:  BCF    FD8.0
0B52:  RRCF   01,F
0B54:  RRCF   02,F
0B56:  RRCF   03,F
0B58:  RRCF   x86,F
0B5A:  BRA    0B60
0B5C:  DECF   00,F
0B5E:  BZ    0BCA
0B60:  BTFSC  x86.7
0B62:  BRA    0BA0
0B64:  BCF    FD8.0
0B66:  RLCF   x81,F
0B68:  RLCF   x82,F
0B6A:  RLCF   x83,F
0B6C:  RLCF   x84,F
0B6E:  MOVF   x80,W
0B70:  SUBWF  x81,F
0B72:  BC    0B82
0B74:  MOVLW  01
0B76:  SUBWF  x82,F
0B78:  BC    0B82
0B7A:  SUBWF  x83,F
0B7C:  BC    0B82
0B7E:  SUBWF  x84,F
0B80:  BNC   0BB6
0B82:  MOVF   x7F,W
0B84:  SUBWF  x82,F
0B86:  BC    0B92
0B88:  MOVLW  01
0B8A:  SUBWF  x83,F
0B8C:  BC    0B92
0B8E:  SUBWF  x84,F
0B90:  BNC   0BB6
0B92:  MOVF   x7E,W
0B94:  IORLW  80
0B96:  SUBWF  x83,F
0B98:  BC    0BA0
0B9A:  MOVLW  01
0B9C:  SUBWF  x84,F
0B9E:  BNC   0BB6
0BA0:  INCF   03,F
0BA2:  BNZ   0BB6
0BA4:  INCF   02,F
0BA6:  BNZ   0BB6
0BA8:  INCF   01,F
0BAA:  BNZ   0BB6
0BAC:  INCF   00,F
0BAE:  BZ    0BCA
0BB0:  RRCF   01,F
0BB2:  RRCF   02,F
0BB4:  RRCF   03,F
0BB6:  MOVFF  7A,85
0BBA:  MOVF   x7E,W
0BBC:  XORWF  x85,F
0BBE:  BTFSS  x85.7
0BC0:  BRA    0BC6
0BC2:  BSF    01.7
0BC4:  BRA    0BD2
0BC6:  BCF    01.7
0BC8:  BRA    0BD2
0BCA:  CLRF   00
0BCC:  CLRF   01
0BCE:  CLRF   02
0BD0:  CLRF   03
0BD2:  RETURN 0
0BD4:  MOVF   x7D,W
0BD6:  BTFSC  FD8.2
0BD8:  BRA    0CBC
0BDA:  MOVWF  00
0BDC:  MOVF   x81,W
0BDE:  BTFSC  FD8.2
0BE0:  BRA    0CBC
0BE2:  ADDWF  00,F
0BE4:  BNC   0BEE
0BE6:  MOVLW  81
0BE8:  ADDWF  00,F
0BEA:  BC    0CBC
0BEC:  BRA    0BF6
0BEE:  MOVLW  7F
0BF0:  SUBWF  00,F
0BF2:  BNC   0CBC
0BF4:  BZ    0CBC
0BF6:  MOVFF  7E,85
0BFA:  MOVF   x82,W
0BFC:  XORWF  x85,F
0BFE:  BSF    x7E.7
0C00:  BSF    x82.7
0C02:  MOVF   x80,W
0C04:  MULWF  x84
0C06:  MOVFF  FF4,87
0C0A:  MOVF   x7F,W
0C0C:  MULWF  x83
0C0E:  MOVFF  FF4,03
0C12:  MOVFF  FF3,86
0C16:  MULWF  x84
0C18:  MOVF   FF3,W
0C1A:  ADDWF  x87,F
0C1C:  MOVF   FF4,W
0C1E:  ADDWFC x86,F
0C20:  MOVLW  00
0C22:  ADDWFC 03,F
0C24:  MOVF   x80,W
0C26:  MULWF  x83
0C28:  MOVF   FF3,W
0C2A:  ADDWF  x87,F
0C2C:  MOVF   FF4,W
0C2E:  ADDWFC x86,F
0C30:  MOVLW  00
0C32:  CLRF   02
0C34:  ADDWFC 03,F
0C36:  ADDWFC 02,F
0C38:  MOVF   x7E,W
0C3A:  MULWF  x84
0C3C:  MOVF   FF3,W
0C3E:  ADDWF  x86,F
0C40:  MOVF   FF4,W
0C42:  ADDWFC 03,F
0C44:  MOVLW  00
0C46:  ADDWFC 02,F
0C48:  MOVF   x7E,W
0C4A:  MULWF  x83
0C4C:  MOVF   FF3,W
0C4E:  ADDWF  03,F
0C50:  MOVF   FF4,W
0C52:  ADDWFC 02,F
0C54:  MOVLW  00
0C56:  CLRF   01
0C58:  ADDWFC 01,F
0C5A:  MOVF   x80,W
0C5C:  MULWF  x82
0C5E:  MOVF   FF3,W
0C60:  ADDWF  x86,F
0C62:  MOVF   FF4,W
0C64:  ADDWFC 03,F
0C66:  MOVLW  00
0C68:  ADDWFC 02,F
0C6A:  ADDWFC 01,F
0C6C:  MOVF   x7F,W
0C6E:  MULWF  x82
0C70:  MOVF   FF3,W
0C72:  ADDWF  03,F
0C74:  MOVF   FF4,W
0C76:  ADDWFC 02,F
0C78:  MOVLW  00
0C7A:  ADDWFC 01,F
0C7C:  MOVF   x7E,W
0C7E:  MULWF  x82
0C80:  MOVF   FF3,W
0C82:  ADDWF  02,F
0C84:  MOVF   FF4,W
0C86:  ADDWFC 01,F
0C88:  INCF   00,F
0C8A:  BTFSC  01.7
0C8C:  BRA    0C98
0C8E:  RLCF   x86,F
0C90:  RLCF   03,F
0C92:  RLCF   02,F
0C94:  RLCF   01,F
0C96:  DECF   00,F
0C98:  MOVLW  00
0C9A:  BTFSS  x86.7
0C9C:  BRA    0CB2
0C9E:  INCF   03,F
0CA0:  ADDWFC 02,F
0CA2:  ADDWFC 01,F
0CA4:  MOVF   01,W
0CA6:  BNZ   0CB2
0CA8:  MOVF   02,W
0CAA:  BNZ   0CB2
0CAC:  MOVF   03,W
0CAE:  BNZ   0CB2
0CB0:  INCF   00,F
0CB2:  BTFSC  x85.7
0CB4:  BSF    01.7
0CB6:  BTFSS  x85.7
0CB8:  BCF    01.7
0CBA:  BRA    0CC4
0CBC:  CLRF   00
0CBE:  CLRF   01
0CC0:  CLRF   02
0CC2:  CLRF   03
0CC4:  RETURN 0
*
0DC4:  MOVLW  80
0DC6:  BTFSC  FD8.1
0DC8:  XORWF  x7A,F
0DCA:  CLRF   x7F
0DCC:  CLRF   x80
0DCE:  MOVFF  76,7E
0DD2:  MOVF   x7A,W
0DD4:  XORWF  x7E,F
0DD6:  MOVF   x75,W
0DD8:  BTFSC  FD8.2
0DDA:  BRA    0F94
0DDC:  MOVWF  x7D
0DDE:  MOVWF  00
0DE0:  MOVF   x79,W
0DE2:  BTFSC  FD8.2
0DE4:  BRA    0FA6
0DE6:  SUBWF  x7D,F
0DE8:  BTFSC  FD8.2
0DEA:  BRA    0EEE
0DEC:  BNC   0E68
0DEE:  MOVFF  7A,83
0DF2:  BSF    x83.7
0DF4:  MOVFF  7B,82
0DF8:  MOVFF  7C,81
0DFC:  CLRF   x80
0DFE:  BCF    FD8.0
0E00:  RRCF   x83,F
0E02:  RRCF   x82,F
0E04:  RRCF   x81,F
0E06:  RRCF   x80,F
0E08:  DECFSZ x7D,F
0E0A:  BRA    0DFC
0E0C:  BTFSS  x7E.7
0E0E:  BRA    0E16
0E10:  BSF    x7F.0
0E12:  BRA    0FCE
0E14:  BCF    x7F.0
0E16:  BCF    x7D.0
0E18:  BSF    x7F.4
0E1A:  CLRF   FEA
0E1C:  MOVLW  78
0E1E:  MOVWF  FE9
0E20:  BRA    0FF4
0E22:  BCF    x7F.4
0E24:  BTFSC  x7E.7
0E26:  BRA    0E3C
0E28:  BTFSS  x7D.0
0E2A:  BRA    0E52
0E2C:  RRCF   x83,F
0E2E:  RRCF   x82,F
0E30:  RRCF   x81,F
0E32:  RRCF   x80,F
0E34:  INCF   00,F
0E36:  BTFSC  FD8.2
0E38:  BRA    0FC4
0E3A:  BRA    0E52
0E3C:  BTFSC  x83.7
0E3E:  BRA    0E58
0E40:  BCF    FD8.0
0E42:  RLCF   x80,F
0E44:  RLCF   x81,F
0E46:  RLCF   x82,F
0E48:  RLCF   x83,F
0E4A:  DECF   00,F
0E4C:  BTFSC  FD8.2
0E4E:  BRA    0FC4
0E50:  BRA    0E3C
0E52:  BSF    x7F.6
0E54:  BRA    0F2C
0E56:  BCF    x7F.6
0E58:  MOVFF  76,7E
0E5C:  BTFSS  x76.7
0E5E:  BRA    0E64
0E60:  BSF    x83.7
0E62:  BRA    0FB6
0E64:  BCF    x83.7
0E66:  BRA    0FB6
0E68:  MOVFF  79,7D
0E6C:  MOVFF  79,00
0E70:  MOVF   x75,W
0E72:  SUBWF  x7D,F
0E74:  MOVFF  76,83
0E78:  BSF    x83.7
0E7A:  MOVFF  77,82
0E7E:  MOVFF  78,81
0E82:  CLRF   x80
0E84:  BCF    FD8.0
0E86:  RRCF   x83,F
0E88:  RRCF   x82,F
0E8A:  RRCF   x81,F
0E8C:  RRCF   x80,F
0E8E:  DECFSZ x7D,F
0E90:  BRA    0E82
0E92:  BTFSS  x7E.7
0E94:  BRA    0E9C
0E96:  BSF    x7F.1
0E98:  BRA    0FCE
0E9A:  BCF    x7F.1
0E9C:  BCF    x7D.0
0E9E:  BSF    x7F.5
0EA0:  CLRF   FEA
0EA2:  MOVLW  7C
0EA4:  MOVWF  FE9
0EA6:  BRA    0FF4
0EA8:  BCF    x7F.5
0EAA:  BTFSC  x7E.7
0EAC:  BRA    0EC2
0EAE:  BTFSS  x7D.0
0EB0:  BRA    0ED8
0EB2:  RRCF   x83,F
0EB4:  RRCF   x82,F
0EB6:  RRCF   x81,F
0EB8:  RRCF   x80,F
0EBA:  INCF   00,F
0EBC:  BTFSC  FD8.2
0EBE:  BRA    0FC4
0EC0:  BRA    0ED8
0EC2:  BTFSC  x83.7
0EC4:  BRA    0EDE
0EC6:  BCF    FD8.0
0EC8:  RLCF   x80,F
0ECA:  RLCF   x81,F
0ECC:  RLCF   x82,F
0ECE:  RLCF   x83,F
0ED0:  DECF   00,F
0ED2:  BTFSC  FD8.2
0ED4:  BRA    0FC4
0ED6:  BRA    0EC2
0ED8:  BSF    x7F.7
0EDA:  BRA    0F2C
0EDC:  BCF    x7F.7
0EDE:  MOVFF  7A,7E
0EE2:  BTFSS  x7A.7
0EE4:  BRA    0EEA
0EE6:  BSF    x83.7
0EE8:  BRA    0FB6
0EEA:  BCF    x83.7
0EEC:  BRA    0FB6
0EEE:  MOVFF  7A,83
0EF2:  BSF    x83.7
0EF4:  MOVFF  7B,82
0EF8:  MOVFF  7C,81
0EFC:  BTFSS  x7E.7
0EFE:  BRA    0F08
0F00:  BCF    x83.7
0F02:  BSF    x7F.2
0F04:  BRA    0FCE
0F06:  BCF    x7F.2
0F08:  CLRF   x80
0F0A:  BCF    x7D.0
0F0C:  CLRF   FEA
0F0E:  MOVLW  78
0F10:  MOVWF  FE9
0F12:  BRA    0FF4
0F14:  BTFSC  x7E.7
0F16:  BRA    0F50
0F18:  MOVFF  76,7E
0F1C:  BTFSS  x7D.0
0F1E:  BRA    0F2C
0F20:  RRCF   x83,F
0F22:  RRCF   x82,F
0F24:  RRCF   x81,F
0F26:  RRCF   x80,F
0F28:  INCF   00,F
0F2A:  BZ    0FC4
0F2C:  BTFSS  x80.7
0F2E:  BRA    0F46
0F30:  INCF   x81,F
0F32:  BNZ   0F46
0F34:  INCF   x82,F
0F36:  BNZ   0F46
0F38:  INCF   x83,F
0F3A:  BNZ   0F46
0F3C:  RRCF   x83,F
0F3E:  RRCF   x82,F
0F40:  RRCF   x81,F
0F42:  INCF   00,F
0F44:  BZ    0FC4
0F46:  BTFSC  x7F.6
0F48:  BRA    0E56
0F4A:  BTFSC  x7F.7
0F4C:  BRA    0EDC
0F4E:  BRA    0F88
0F50:  MOVLW  80
0F52:  XORWF  x83,F
0F54:  BTFSS  x83.7
0F56:  BRA    0F60
0F58:  BRA    0FCE
0F5A:  MOVFF  7A,7E
0F5E:  BRA    0F74
0F60:  MOVFF  76,7E
0F64:  MOVF   x83,F
0F66:  BNZ   0F74
0F68:  MOVF   x82,F
0F6A:  BNZ   0F74
0F6C:  MOVF   x81,F
0F6E:  BNZ   0F74
0F70:  CLRF   00
0F72:  BRA    0FB6
0F74:  BTFSC  x83.7
0F76:  BRA    0F88
0F78:  BCF    FD8.0
0F7A:  RLCF   x80,F
0F7C:  RLCF   x81,F
0F7E:  RLCF   x82,F
0F80:  RLCF   x83,F
0F82:  DECFSZ 00,F
0F84:  BRA    0F74
0F86:  BRA    0FC4
0F88:  BTFSS  x7E.7
0F8A:  BRA    0F90
0F8C:  BSF    x83.7
0F8E:  BRA    0FB6
0F90:  BCF    x83.7
0F92:  BRA    0FB6
0F94:  MOVFF  79,00
0F98:  MOVFF  7A,83
0F9C:  MOVFF  7B,82
0FA0:  MOVFF  7C,81
0FA4:  BRA    0FB6
0FA6:  MOVFF  75,00
0FAA:  MOVFF  76,83
0FAE:  MOVFF  77,82
0FB2:  MOVFF  78,81
0FB6:  MOVFF  83,01
0FBA:  MOVFF  82,02
0FBE:  MOVFF  81,03
0FC2:  BRA    102C
0FC4:  CLRF   00
0FC6:  CLRF   01
0FC8:  CLRF   02
0FCA:  CLRF   03
0FCC:  BRA    102C
0FCE:  CLRF   x80
0FD0:  COMF   x81,F
0FD2:  COMF   x82,F
0FD4:  COMF   x83,F
0FD6:  COMF   x80,F
0FD8:  INCF   x80,F
0FDA:  BNZ   0FE6
0FDC:  INCF   x81,F
0FDE:  BNZ   0FE6
0FE0:  INCF   x82,F
0FE2:  BNZ   0FE6
0FE4:  INCF   x83,F
0FE6:  BTFSC  x7F.0
0FE8:  BRA    0E14
0FEA:  BTFSC  x7F.1
0FEC:  BRA    0E9A
0FEE:  BTFSC  x7F.2
0FF0:  BRA    0F06
0FF2:  BRA    0F5A
0FF4:  MOVF   FEF,W
0FF6:  ADDWF  x81,F
0FF8:  BNC   1004
0FFA:  INCF   x82,F
0FFC:  BNZ   1004
0FFE:  INCF   x83,F
1000:  BTFSC  FD8.2
1002:  BSF    x7D.0
1004:  MOVF   FED,F
1006:  MOVF   FEF,W
1008:  ADDWF  x82,F
100A:  BNC   1012
100C:  INCF   x83,F
100E:  BTFSC  FD8.2
1010:  BSF    x7D.0
1012:  MOVF   FED,F
1014:  MOVF   FEF,W
1016:  BTFSC  FEF.7
1018:  BRA    101C
101A:  XORLW  80
101C:  ADDWF  x83,F
101E:  BTFSC  FD8.0
1020:  BSF    x7D.0
1022:  BTFSC  x7F.4
1024:  BRA    0E22
1026:  BTFSC  x7F.5
1028:  BRA    0EA8
102A:  BRA    0F14
102C:  RETURN 0
102E:  MOVFF  76,7D
1032:  MOVF   x7A,W
1034:  XORWF  x7D,F
1036:  BTFSS  x7D.7
1038:  BRA    1044
103A:  BCF    FD8.2
103C:  BCF    FD8.0
103E:  BTFSC  x76.7
1040:  BSF    FD8.0
1042:  BRA    10A2
1044:  MOVFF  76,7D
1048:  MOVFF  79,7E
104C:  MOVF   x75,W
104E:  SUBWF  x7E,F
1050:  BZ    105E
1052:  BTFSS  x7D.7
1054:  BRA    10A2
1056:  MOVF   FD8,W
1058:  XORLW  01
105A:  MOVWF  FD8
105C:  BRA    10A2
105E:  MOVFF  7A,7E
1062:  MOVF   x76,W
1064:  SUBWF  x7E,F
1066:  BZ    1074
1068:  BTFSS  x7D.7
106A:  BRA    10A2
106C:  MOVF   FD8,W
106E:  XORLW  01
1070:  MOVWF  FD8
1072:  BRA    10A2
1074:  MOVFF  7B,7E
1078:  MOVF   x77,W
107A:  SUBWF  x7E,F
107C:  BZ    108A
107E:  BTFSS  x7D.7
1080:  BRA    10A2
1082:  MOVF   FD8,W
1084:  XORLW  01
1086:  MOVWF  FD8
1088:  BRA    10A2
108A:  MOVFF  7C,7E
108E:  MOVF   x78,W
1090:  SUBWF  x7E,F
1092:  BZ    10A0
1094:  BTFSS  x7D.7
1096:  BRA    10A2
1098:  MOVF   FD8,W
109A:  XORLW  01
109C:  MOVWF  FD8
109E:  BRA    10A2
10A0:  BCF    FD8.0
10A2:  RETURN 0
*
168C:  MOVF   5F,W
168E:  SUBLW  B6
1690:  MOVWF  5F
1692:  CLRF   03
1694:  MOVFF  60,63
1698:  BSF    x60.7
169A:  BCF    FD8.0
169C:  RRCF   x60,F
169E:  RRCF   x61,F
16A0:  RRCF   x62,F
16A2:  RRCF   03,F
16A4:  RRCF   02,F
16A6:  RRCF   01,F
16A8:  RRCF   00,F
16AA:  DECFSZ 5F,F
16AC:  BRA    169A
16AE:  BTFSS  x63.7
16B0:  BRA    16C8
16B2:  COMF   00,F
16B4:  COMF   01,F
16B6:  COMF   02,F
16B8:  COMF   03,F
16BA:  INCF   00,F
16BC:  BTFSC  FD8.2
16BE:  INCF   01,F
16C0:  BTFSC  FD8.2
16C2:  INCF   02,F
16C4:  BTFSC  FD8.2
16C6:  INCF   03,F
16C8:  RETURN 0
16CA:  BTFSC  FD8.1
16CC:  BRA    16D4
16CE:  CLRF   FEA
16D0:  MOVLW  68
16D2:  MOVWF  FE9
16D4:  CLRF   00
16D6:  CLRF   01
16D8:  CLRF   02
16DA:  CLRF   03
16DC:  CLRF   x68
16DE:  CLRF   x69
16E0:  CLRF   x6A
16E2:  CLRF   x6B
16E4:  MOVF   x67,W
16E6:  IORWF  x66,W
16E8:  IORWF  x65,W
16EA:  IORWF  x64,W
16EC:  BZ    1746
16EE:  MOVLW  20
16F0:  MOVWF  x6C
16F2:  BCF    FD8.0
16F4:  RLCF   x60,F
16F6:  RLCF   x61,F
16F8:  RLCF   x62,F
16FA:  RLCF   x63,F
16FC:  RLCF   x68,F
16FE:  RLCF   x69,F
1700:  RLCF   x6A,F
1702:  RLCF   x6B,F
1704:  MOVF   x67,W
1706:  SUBWF  x6B,W
1708:  BNZ   171A
170A:  MOVF   x66,W
170C:  SUBWF  x6A,W
170E:  BNZ   171A
1710:  MOVF   x65,W
1712:  SUBWF  x69,W
1714:  BNZ   171A
1716:  MOVF   x64,W
1718:  SUBWF  x68,W
171A:  BNC   173A
171C:  MOVF   x64,W
171E:  SUBWF  x68,F
1720:  MOVF   x65,W
1722:  BTFSS  FD8.0
1724:  INCFSZ x65,W
1726:  SUBWF  x69,F
1728:  MOVF   x66,W
172A:  BTFSS  FD8.0
172C:  INCFSZ x66,W
172E:  SUBWF  x6A,F
1730:  MOVF   x67,W
1732:  BTFSS  FD8.0
1734:  INCFSZ x67,W
1736:  SUBWF  x6B,F
1738:  BSF    FD8.0
173A:  RLCF   00,F
173C:  RLCF   01,F
173E:  RLCF   02,F
1740:  RLCF   03,F
1742:  DECFSZ x6C,F
1744:  BRA    16F2
1746:  MOVFF  68,FEF
174A:  MOVFF  69,FEC
174E:  MOVFF  6A,FEC
1752:  MOVFF  6B,FEC
1756:  RETURN 0
1758:  MOVF   FE9,W
175A:  MOVWF  57
175C:  MOVF   56,W
175E:  MOVWF  59
1760:  BZ    1796
1762:  MOVFF  55,80
1766:  MOVFF  54,7F
176A:  MOVFF  53,7E
176E:  MOVFF  52,7D
1772:  CLRF   x84
1774:  CLRF   x83
1776:  MOVLW  20
1778:  MOVWF  x82
177A:  MOVLW  82
177C:  MOVWF  x81
177E:  CALL   0BD4
1782:  MOVFF  03,55
1786:  MOVFF  02,54
178A:  MOVFF  01,53
178E:  MOVFF  00,52
1792:  DECFSZ 59,F
1794:  BRA    1762
1796:  MOVFF  55,62
179A:  MOVFF  54,61
179E:  MOVFF  53,60
17A2:  MOVFF  52,5F
17A6:  RCALL  168C
17A8:  MOVFF  03,55
17AC:  MOVFF  02,54
17B0:  MOVFF  01,53
17B4:  MOVFF  00,52
17B8:  BTFSS  55.7
17BA:  BRA    17D6
17BC:  DECF   57,F
17BE:  BSF    57.5
17C0:  COMF   52,F
17C2:  COMF   53,F
17C4:  COMF   54,F
17C6:  COMF   55,F
17C8:  INCF   52,F
17CA:  BTFSC  FD8.2
17CC:  INCF   53,F
17CE:  BTFSC  FD8.2
17D0:  INCF   54,F
17D2:  BTFSC  FD8.2
17D4:  INCF   55,F
17D6:  MOVLW  3B
17D8:  MOVWF  5E
17DA:  MOVLW  9A
17DC:  MOVWF  5D
17DE:  MOVLW  CA
17E0:  MOVWF  5C
17E2:  CLRF   5B
17E4:  MOVLW  0A
17E6:  MOVWF  59
17E8:  MOVF   56,W
17EA:  BTFSC  FD8.2
17EC:  INCF   57,F
17EE:  BSF    FD8.1
17F0:  CLRF   FEA
17F2:  MOVLW  52
17F4:  MOVWF  FE9
17F6:  MOVFF  55,63
17FA:  MOVFF  54,62
17FE:  MOVFF  53,61
1802:  MOVFF  52,60
1806:  MOVFF  5E,67
180A:  MOVFF  5D,66
180E:  MOVFF  5C,65
1812:  MOVFF  5B,64
1816:  RCALL  16CA
1818:  MOVF   01,W
181A:  MOVF   00,F
181C:  BNZ   183C
181E:  INCF   56,W
1820:  SUBWF  59,W
1822:  BZ    183C
1824:  MOVF   57,W
1826:  BZ    1840
1828:  ANDLW  0F
182A:  SUBWF  59,W
182C:  BZ    1830
182E:  BC    18A6
1830:  BTFSC  57.7
1832:  BRA    18A6
1834:  BTFSC  57.6
1836:  BRA    1840
1838:  MOVLW  20
183A:  BRA    189C
183C:  MOVLW  20
183E:  ANDWF  57,F
1840:  BTFSS  57.5
1842:  BRA    185E
1844:  BCF    57.5
1846:  MOVF   56,W
1848:  BTFSS  FD8.2
184A:  DECF   57,F
184C:  MOVF   00,W
184E:  MOVWF  57
1850:  MOVLW  2D
1852:  BTFSS  F9E.4
1854:  BRA    1852
1856:  MOVWF  FAD
1858:  MOVF   57,W
185A:  MOVWF  00
185C:  CLRF   57
185E:  MOVF   56,W
1860:  SUBWF  59,W
1862:  BNZ   187A
1864:  MOVF   00,W
1866:  MOVWF  57
1868:  MOVLW  2E
186A:  BTFSS  F9E.4
186C:  BRA    186A
186E:  MOVWF  FAD
1870:  MOVF   57,W
1872:  MOVWF  00
1874:  MOVLW  20
1876:  ANDWF  57,F
1878:  MOVLW  00
187A:  MOVLW  30
187C:  BTFSS  57.5
187E:  BRA    189C
1880:  BCF    57.5
1882:  MOVF   56,W
1884:  BTFSS  FD8.2
1886:  DECF   57,F
1888:  MOVF   00,W
188A:  MOVWF  57
188C:  MOVLW  2D
188E:  BTFSS  F9E.4
1890:  BRA    188E
1892:  MOVWF  FAD
1894:  MOVF   57,W
1896:  MOVWF  00
1898:  CLRF   57
189A:  MOVLW  30
189C:  ADDWF  00,F
189E:  MOVF   00,W
18A0:  BTFSS  F9E.4
18A2:  BRA    18A0
18A4:  MOVWF  FAD
18A6:  BCF    FD8.1
18A8:  MOVFF  5E,63
18AC:  MOVFF  5D,62
18B0:  MOVFF  5C,61
18B4:  MOVFF  5B,60
18B8:  CLRF   x67
18BA:  CLRF   x66
18BC:  CLRF   x65
18BE:  MOVLW  0A
18C0:  MOVWF  x64
18C2:  RCALL  16CA
18C4:  MOVFF  03,5E
18C8:  MOVFF  02,5D
18CC:  MOVFF  01,5C
18D0:  MOVFF  00,5B
18D4:  DECFSZ 59,F
18D6:  BRA    17EE
18D8:  RETURN 0
*
1914:  MOVFF  FF2,0D
1918:  BCF    FF2.7
191A:  ADDWF  FE8,W
191C:  CLRF   FF7
191E:  RLCF   FF7,F
1920:  ADDLW  39
1922:  MOVWF  FF6
1924:  MOVLW  19
1926:  ADDWFC FF7,F
1928:  TBLRD*-
192A:  MOVF   FF5,W
192C:  MOVWF  FFA
192E:  TBLRD*
1930:  MOVF   FF5,W
1932:  BTFSC  0D.7
1934:  BSF    FF2.7
1936:  MOVWF  FF9
1938:  DATA E8,18
193A:  DATA EE,18
193C:  DATA F4,18
193E:  DATA FA,18
*
198A:  MOVF   FE9,W
198C:  MOVWF  57
198E:  MOVF   56,W
1990:  MOVWF  59
1992:  BZ    19C8
1994:  MOVFF  55,80
1998:  MOVFF  54,7F
199C:  MOVFF  53,7E
19A0:  MOVFF  52,7D
19A4:  CLRF   x84
19A6:  CLRF   x83
19A8:  MOVLW  20
19AA:  MOVWF  x82
19AC:  MOVLW  82
19AE:  MOVWF  x81
19B0:  CALL   0BD4
19B4:  MOVFF  03,55
19B8:  MOVFF  02,54
19BC:  MOVFF  01,53
19C0:  MOVFF  00,52
19C4:  DECFSZ 59,F
19C6:  BRA    1994
19C8:  MOVFF  55,62
19CC:  MOVFF  54,61
19D0:  MOVFF  53,60
19D4:  MOVFF  52,5F
19D8:  RCALL  168C
19DA:  MOVFF  03,55
19DE:  MOVFF  02,54
19E2:  MOVFF  01,53
19E6:  MOVFF  00,52
19EA:  BTFSS  55.7
19EC:  BRA    1A08
19EE:  DECF   57,F
19F0:  BSF    57.5
19F2:  COMF   52,F
19F4:  COMF   53,F
19F6:  COMF   54,F
19F8:  COMF   55,F
19FA:  INCF   52,F
19FC:  BTFSC  FD8.2
19FE:  INCF   53,F
1A00:  BTFSC  FD8.2
1A02:  INCF   54,F
1A04:  BTFSC  FD8.2
1A06:  INCF   55,F
1A08:  MOVLW  3B
1A0A:  MOVWF  5E
1A0C:  MOVLW  9A
1A0E:  MOVWF  5D
1A10:  MOVLW  CA
1A12:  MOVWF  5C
1A14:  CLRF   5B
1A16:  MOVLW  0A
1A18:  MOVWF  59
1A1A:  MOVF   56,W
1A1C:  BTFSC  FD8.2
1A1E:  INCF   57,F
1A20:  BSF    FD8.1
1A22:  CLRF   FEA
1A24:  MOVLW  52
1A26:  MOVWF  FE9
1A28:  MOVFF  55,63
1A2C:  MOVFF  54,62
1A30:  MOVFF  53,61
1A34:  MOVFF  52,60
1A38:  MOVFF  5E,67
1A3C:  MOVFF  5D,66
1A40:  MOVFF  5C,65
1A44:  MOVFF  5B,64
1A48:  RCALL  16CA
1A4A:  MOVF   01,W
1A4C:  MOVF   00,F
1A4E:  BNZ   1A6E
1A50:  INCF   56,W
1A52:  SUBWF  59,W
1A54:  BZ    1A6E
1A56:  MOVF   57,W
1A58:  BZ    1A72
1A5A:  ANDLW  0F
1A5C:  SUBWF  59,W
1A5E:  BZ    1A62
1A60:  BC    1AD0
1A62:  BTFSC  57.7
1A64:  BRA    1AD0
1A66:  BTFSC  57.6
1A68:  BRA    1A72
1A6A:  MOVLW  20
1A6C:  BRA    1AC8
1A6E:  MOVLW  20
1A70:  ANDWF  57,F
1A72:  BTFSS  57.5
1A74:  BRA    1A8E
1A76:  BCF    57.5
1A78:  MOVF   56,W
1A7A:  BTFSS  FD8.2
1A7C:  DECF   57,F
1A7E:  MOVF   00,W
1A80:  MOVWF  57
1A82:  MOVLW  2D
1A84:  MOVWF  5F
1A86:  RCALL  1940
1A88:  MOVF   57,W
1A8A:  MOVWF  00
1A8C:  CLRF   57
1A8E:  MOVF   56,W
1A90:  SUBWF  59,W
1A92:  BNZ   1AA8
1A94:  MOVF   00,W
1A96:  MOVWF  57
1A98:  MOVLW  2E
1A9A:  MOVWF  5F
1A9C:  RCALL  1940
1A9E:  MOVF   57,W
1AA0:  MOVWF  00
1AA2:  MOVLW  20
1AA4:  ANDWF  57,F
1AA6:  MOVLW  00
1AA8:  MOVLW  30
1AAA:  BTFSS  57.5
1AAC:  BRA    1AC8
1AAE:  BCF    57.5
1AB0:  MOVF   56,W
1AB2:  BTFSS  FD8.2
1AB4:  DECF   57,F
1AB6:  MOVF   00,W
1AB8:  MOVWF  57
1ABA:  MOVLW  2D
1ABC:  MOVWF  5F
1ABE:  RCALL  1940
1AC0:  MOVF   57,W
1AC2:  MOVWF  00
1AC4:  CLRF   57
1AC6:  MOVLW  30
1AC8:  ADDWF  00,F
1ACA:  MOVFF  00,5F
1ACE:  RCALL  1940
1AD0:  BCF    FD8.1
1AD2:  MOVFF  5E,63
1AD6:  MOVFF  5D,62
1ADA:  MOVFF  5C,61
1ADE:  MOVFF  5B,60
1AE2:  CLRF   x67
1AE4:  CLRF   x66
1AE6:  CLRF   x65
1AE8:  MOVLW  0A
1AEA:  MOVWF  x64
1AEC:  RCALL  16CA
1AEE:  MOVFF  03,5E
1AF2:  MOVFF  02,5D
1AF6:  MOVFF  01,5C
1AFA:  MOVFF  00,5B
1AFE:  DECFSZ 59,F
1B00:  BRA    1A20
1B02:  GOTO   2182 (RETURN)
1B06:  TBLRD*+
1B08:  MOVF   FF5,F
1B0A:  BZ    1B24
1B0C:  MOVFF  FF6,52
1B10:  MOVFF  FF7,53
1B14:  MOVFF  FF5,5F
1B18:  RCALL  1940
1B1A:  MOVFF  52,FF6
1B1E:  MOVFF  53,FF7
1B22:  BRA    1B06
1B24:  GOTO   2198 (RETURN)
*
1D0A:  MOVF   FE9,W
1D0C:  MOVWF  58
1D0E:  MOVLW  3B
1D10:  MOVWF  5F
1D12:  MOVLW  9A
1D14:  MOVWF  5E
1D16:  MOVLW  CA
1D18:  MOVWF  5D
1D1A:  CLRF   5C
1D1C:  MOVLW  0A
1D1E:  MOVWF  5A
1D20:  BSF    FD8.1
1D22:  CLRF   FEA
1D24:  MOVLW  54
1D26:  MOVWF  FE9
1D28:  MOVFF  57,63
1D2C:  MOVFF  56,62
1D30:  MOVFF  55,61
1D34:  MOVFF  54,60
1D38:  MOVFF  5F,67
1D3C:  MOVFF  5E,66
1D40:  MOVFF  5D,65
1D44:  MOVFF  5C,64
1D48:  RCALL  16CA
1D4A:  MOVF   01,W
1D4C:  MOVF   00,F
1D4E:  BNZ   1D6E
1D50:  MOVF   5A,W
1D52:  XORLW  01
1D54:  BZ    1D6E
1D56:  MOVF   58,W
1D58:  BZ    1D70
1D5A:  ANDLW  0F
1D5C:  SUBWF  5A,W
1D5E:  BZ    1D62
1D60:  BC    1D7C
1D62:  BTFSC  58.7
1D64:  BRA    1D7C
1D66:  BTFSC  58.6
1D68:  BRA    1D70
1D6A:  MOVLW  20
1D6C:  BRA    1D72
1D6E:  CLRF   58
1D70:  MOVLW  30
1D72:  ADDWF  00,F
1D74:  MOVF   00,W
1D76:  BTFSS  F9E.4
1D78:  BRA    1D76
1D7A:  MOVWF  FAD
1D7C:  BCF    FD8.1
1D7E:  MOVFF  5F,63
1D82:  MOVFF  5E,62
1D86:  MOVFF  5D,61
1D8A:  MOVFF  5C,60
1D8E:  CLRF   x67
1D90:  CLRF   x66
1D92:  CLRF   x65
1D94:  MOVLW  0A
1D96:  MOVWF  x64
1D98:  RCALL  16CA
1D9A:  MOVFF  03,5F
1D9E:  MOVFF  02,5E
1DA2:  MOVFF  01,5D
1DA6:  MOVFF  00,5C
1DAA:  DECFSZ 5A,F
1DAC:  BRA    1D20
1DAE:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses HS,NOPROTECT,NOLVP,NOWDT 
.................... #device 18F2480*=16, ADC=8 
.................... #use delay(clock=20000000) 
*
04C4:  CLRF   FEA
04C6:  MOVLW  71
04C8:  MOVWF  FE9
04CA:  MOVF   FEF,W
04CC:  BZ    04E8
04CE:  MOVLW  06
04D0:  MOVWF  01
04D2:  CLRF   00
04D4:  DECFSZ 00,F
04D6:  BRA    04D4
04D8:  DECFSZ 01,F
04DA:  BRA    04D2
04DC:  MOVLW  7B
04DE:  MOVWF  00
04E0:  DECFSZ 00,F
04E2:  BRA    04E0
04E4:  DECFSZ FEF,F
04E6:  BRA    04CE
04E8:  RETURN 0
.................... #use rs232(baud=38400, xmit=PIN_C6, rcv=PIN_C7) 
.................... #use fast_io(c) 
.................... #include <can-18xxx8.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.c                             //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18xxx8 CAN peripheral           //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers          //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode      //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID               //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID         //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID           //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the      //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data                                     //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions                 //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.    //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  May 18 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 20 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - updated can_init() function to setup correct tris  //// 
.................... ////              register for PIC being used.                       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18xxx8.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18xxx8.h                             //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18xxx8.c)                                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18xxx8_LIB_DEFINES__ 
.................... #define __CCS_CAN18xxx8_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... enum CAN_OP_MODE {CAN_OP_CONFIG=4, CAN_OP_LISTEN=3, CAN_OP_LOOPBACK=2, CAN_OP_DISABLE=1, CAN_OP_NORMAL=0}; 
.................... enum CAN_WIN_ADDRESS {CAN_WIN_RX0=0, CAN_WIN_RX1=5, CAN_WIN_TX0=4, CAN_WIN_TX1=3, CAN_WIN_TX2=2}; 
....................  
.................... //can control 
.................... struct { 
....................    int1 void0; //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3 //window address bits 
....................    int1 abat;   //4 //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;   //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")   //0xF6F 
....................  
....................  
.................... enum CAN_INT_CODE {CAN_INT_WAKEUP=7, CAN_INT_RX0=6, CAN_INT_RX1=5, CAN_INT_TX0=4, CAN_INT_TX1=3, CAN_INT_TX2=2, CAN_INT_ERROR=1, CAN_INT_NO=0}; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;   //0 
....................    CAN_INT_CODE icode:3;   //1:3   //interrupt code 
....................    int1 void4;   //4 
....................    CAN_OP_MODE opmode:3;   //5:7   //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")   //0xF6E 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;      //0 //error warning 
....................    int1 rxwarn;      //1 //receiver warning 
....................    int1 txwarn;      //2 //transmitter warning 
....................    int1 rxbp;   //3 //receiver bus passive 
....................    int1 txbp;   //4 //transmitter bus passive bit 
....................    int1 txbo;   //5   //transmitter bus off 
....................    int1 rx1ovfl;   //6   //receive buffer 1 overflow 
....................    int1 rx0ovfl;   //7   //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT= getenv("SFR:COMSTAT") //0xF74 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5   //baud rate prescalar 
....................    int sjw:2;   //6:7   //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")   //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3; //0:2 //propagation time select 
....................    int seg1ph:3; //3:5 //phase segment 1 
....................    int1 sam; //6 //sample of the can bus line 
....................    int1 seg2phts; //7 //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")   //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;   //0:2   //phase segment 2 time select 
....................    int void543:3;   //3:5 
....................    int1 wakfil;   //6 //selects can bus line filter for wake-up 
....................    int1 void7;   //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")   //0xF72 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;   //0:3 
....................    int1 cancap;   //4 //can message receive capture 
....................    int1 endrhi;   //5 //enable drive high 
....................    int1 tx2en;    //6   //CANTX2 Pin Enable bit       //added 3/30/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;   //7   //CANTX2 Pin Data Source bit  //added 3/30/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //transmit buffer n control register 
.................... struct txbNcon_struct { 
....................    int  txpri:2;   //0:1   //transmit priority bits 
....................    int1 void2; //2 
....................    int1 txreq;   //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;   //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;   //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte   TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte   TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte   TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON =     0xF60             // txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      // 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      // 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      // 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      // 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      // 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      // 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //tsb2eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;   //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr; //6 //transmission frame remote transmission 
....................    int1 void7; //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT=getenv("SFR:TXERRCNT")     //0xF76 
....................  
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
....................  
.................... //receive buffer 0 control register 
.................... struct { 
....................    int1 filthit0;   //0 //filter hit 
....................    int1 jtoff;   //1 //jump table offset 
....................    int1 rxb0dben;   //2 //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receiver buffer mode 
....................    int1 rxful;   //7 //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 1 control register 
.................... struct { 
....................    int filthit:3;   //0:2 
....................    int1 rxrtrro;   //3 //receive remote transfer request 
....................    int1 void4;   //4 
....................    CAN_RX_MODE rxm:2;   //5:6 //receive buffer mode 
....................    int1 rxful;   //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")     //0xF50 
....................  
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL=0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;   //extended id 
....................    int1 srr;   //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL=0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0; //4 //reserved 
....................    int1 rb1;   //5 //reserved 
....................    int1 rtr;   //6 //receiver remote transmission request bit 
....................    int1 void7;   //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0=0xF66 
.................... #byte TXRXBaD7=0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   // 0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   // 0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   // 0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   // 0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   // 0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl; 
....................    int filthit:3; 
....................    int1 buffer; 
....................    int1 rtr; 
....................    int1 ext; 
....................    int1 inv; 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_id(unsigned int* addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
....................  
.................... //macros 
.................... #define can_kbhit()                 (RXB0CON.rxful || RXB1CON.rxful) 
.................... #define can_tbe()                   (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
0756:  MOVLW  04
0758:  MOVWF  52
075A:  RCALL  05D4
....................    can_set_baud(); 
075C:  BRA    05F6
....................  
....................    RXB0CON=0; 
075E:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
0760:  MOVLW  9F
0762:  ANDWF  F60,W
0764:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
0766:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
0768:  MOVFF  F60,F50
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
076C:  BCF    F73.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
076E:  BCF    F73.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added 3/30/09 for PIC18F6585/8585/6680/8680 
0770:  BCF    F73.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added 3/30/09 for PIC18F6585/8585/6680/8680 
0772:  BCF    F73.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
0774:  MOVLW  0F
0776:  MOVWF  x63
0778:  MOVLW  1B
077A:  MOVWF  x62
077C:  CLRF   x67
077E:  CLRF   x66
0780:  CLRF   x65
0782:  CLRF   x64
0784:  MOVLW  01
0786:  MOVWF  x68
0788:  RCALL  0626
....................    can_set_id(RX0FILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
078A:  MOVLW  0F
078C:  MOVWF  x63
078E:  MOVLW  03
0790:  MOVWF  x62
0792:  CLRF   x67
0794:  CLRF   x66
0796:  CLRF   x65
0798:  CLRF   x64
079A:  MOVLW  01
079C:  MOVWF  x68
079E:  RCALL  0626
....................    can_set_id(RX0FILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
07A0:  MOVLW  0F
07A2:  MOVWF  x63
07A4:  MOVLW  07
07A6:  MOVWF  x62
07A8:  CLRF   x67
07AA:  CLRF   x66
07AC:  CLRF   x65
07AE:  CLRF   x64
07B0:  MOVLW  01
07B2:  MOVWF  x68
07B4:  RCALL  0626
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
07B6:  MOVLW  0F
07B8:  MOVWF  x63
07BA:  MOVLW  1F
07BC:  MOVWF  x62
07BE:  CLRF   x67
07C0:  CLRF   x66
07C2:  CLRF   x65
07C4:  CLRF   x64
07C6:  MOVLW  01
07C8:  MOVWF  x68
07CA:  RCALL  0626
....................    can_set_id(RX1FILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
07CC:  MOVLW  0F
07CE:  MOVWF  x63
07D0:  MOVLW  0B
07D2:  MOVWF  x62
07D4:  CLRF   x67
07D6:  CLRF   x66
07D8:  CLRF   x65
07DA:  CLRF   x64
07DC:  MOVLW  01
07DE:  MOVWF  x68
07E0:  RCALL  0626
....................    can_set_id(RX1FILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
07E2:  MOVLW  0F
07E4:  MOVWF  x63
07E6:  MOVWF  x62
07E8:  CLRF   x67
07EA:  CLRF   x66
07EC:  CLRF   x65
07EE:  CLRF   x64
07F0:  MOVLW  01
07F2:  MOVWF  x68
07F4:  RCALL  0626
....................    can_set_id(RX1FILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
07F6:  MOVLW  0F
07F8:  MOVWF  x63
07FA:  MOVLW  13
07FC:  MOVWF  x62
07FE:  CLRF   x67
0800:  CLRF   x66
0802:  CLRF   x65
0804:  CLRF   x64
0806:  MOVLW  01
0808:  MOVWF  x68
080A:  RCALL  0626
....................    can_set_id(RX1FILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
080C:  MOVLW  0F
080E:  MOVWF  x63
0810:  MOVLW  17
0812:  MOVWF  x62
0814:  CLRF   x67
0816:  CLRF   x66
0818:  CLRF   x65
081A:  CLRF   x64
081C:  MOVLW  01
081E:  MOVWF  x68
0820:  RCALL  0626
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") || \ 
....................       (getenv("DEVICE") == "PIC18C658") || (getenv("DEVICE") == "PIC18C858") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
0822:  MOVF   F93,W
0824:  ANDLW  FB
0826:  IORLW  08
0828:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
082A:  CLRF   52
082C:  RCALL  05D4
082E:  GOTO   1F0C (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
05F6:  MOVLW  C0
05F8:  ANDWF  F70,W
05FA:  IORLW  04
05FC:  MOVWF  F70
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
05FE:  MOVLW  3F
0600:  ANDWF  F70,W
0602:  MOVWF  F70
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
0604:  MOVLW  F8
0606:  ANDWF  F71,W
0608:  IORLW  02
060A:  MOVWF  F71
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
060C:  MOVLW  C7
060E:  ANDWF  F71,W
0610:  IORLW  28
0612:  MOVWF  F71
....................    BRGCON2.sam=CAN_BRG_SAM; 
0614:  BCF    F71.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
0616:  BSF    F71.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
0618:  MOVLW  F8
061A:  ANDWF  F72,W
061C:  IORLW  05
061E:  MOVWF  F72
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0620:  BCF    F72.6
0622:  GOTO   075E (RETURN)
.................... } 
....................  
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
05D4:  SWAPF  52,W
05D6:  ANDLW  70
05D8:  MOVWF  00
05DA:  BCF    FD8.0
05DC:  RLCF   00,F
05DE:  MOVLW  1F
05E0:  ANDWF  F6F,W
05E2:  IORWF  00,W
05E4:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
05E6:  MOVFF  F6E,00
05EA:  SWAPF  00,F
05EC:  RRCF   00,W
05EE:  ANDLW  07
05F0:  SUBWF  52,W
05F2:  BNZ   05E6
05F4:  RETURN 0
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int* addr, unsigned int32 id, int1 ext) { 
....................    int *ptr; 
....................  
....................    ptr=addr; 
*
0626:  MOVFF  63,6A
062A:  MOVFF  62,69
....................  
....................    if (ext) {  //extended 
062E:  MOVF   x68,F
0630:  BZ    06D6
....................       //eidl 
....................       *ptr=make8(id,0); //0:7 
0632:  MOVFF  69,FE9
0636:  MOVFF  6A,FEA
063A:  MOVFF  64,FEF
....................  
....................       //eidh 
....................       ptr--; 
063E:  MOVF   x69,W
0640:  BTFSC  FD8.2
0642:  DECF   x6A,F
0644:  DECF   x69,F
....................       *ptr=make8(id,1); //8:15 
0646:  MOVFF  69,FE9
064A:  MOVFF  6A,FEA
064E:  MOVFF  65,FEF
....................  
....................       //sidl 
....................       ptr--; 
0652:  MOVF   x69,W
0654:  BTFSC  FD8.2
0656:  DECF   x6A,F
0658:  DECF   x69,F
....................       *ptr=make8(id,2) & 0x03;   //16:17 
065A:  MOVFF  69,FE9
065E:  MOVFF  6A,FEA
0662:  MOVF   x66,W
0664:  ANDLW  03
0666:  MOVWF  FEF
....................       *ptr|=(make8(id,2) << 3) & 0xE0; //18:20 
0668:  MOVFF  69,FE9
066C:  MOVFF  6A,FEA
0670:  MOVFF  66,00
0674:  RLCF   00,F
0676:  RLCF   00,F
0678:  RLCF   00,F
067A:  MOVLW  F8
067C:  ANDWF  00,F
067E:  MOVF   00,W
0680:  ANDLW  E0
0682:  IORWF  FEF,W
0684:  MOVWF  FEF
....................       *ptr|=0x08; 
0686:  MOVFF  69,FE9
068A:  MOVFF  6A,FEA
068E:  MOVF   FEF,W
0690:  IORLW  08
0692:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       ptr--; 
0694:  MOVF   x69,W
0696:  BTFSC  FD8.2
0698:  DECF   x6A,F
069A:  DECF   x69,F
....................       *ptr=((make8(id,2) >> 5) & 0x07 ); //21:23 
069C:  MOVFF  69,FE9
06A0:  MOVFF  6A,FEA
06A4:  MOVFF  66,00
06A8:  SWAPF  00,F
06AA:  RRCF   00,F
06AC:  MOVLW  07
06AE:  ANDWF  00,F
06B0:  MOVF   00,W
06B2:  ANDLW  07
06B4:  MOVWF  FEF
....................       *ptr|=((make8(id,3) << 3) & 0xF8);//24:28 
06B6:  MOVFF  69,FE9
06BA:  MOVFF  6A,FEA
06BE:  MOVFF  67,00
06C2:  RLCF   00,F
06C4:  RLCF   00,F
06C6:  RLCF   00,F
06C8:  MOVLW  F8
06CA:  ANDWF  00,F
06CC:  MOVF   00,W
06CE:  ANDLW  F8
06D0:  IORWF  FEF,W
06D2:  MOVWF  FEF
....................    } 
06D4:  BRA    0754
....................    else {   //standard 
....................       //eidl 
....................       *ptr=0; 
06D6:  MOVFF  69,FE9
06DA:  MOVFF  6A,FEA
06DE:  CLRF   FEF
....................  
....................       //eidh 
....................       ptr--; 
06E0:  MOVF   x69,W
06E2:  BTFSC  FD8.2
06E4:  DECF   x6A,F
06E6:  DECF   x69,F
....................       *ptr=0; 
06E8:  MOVFF  69,FE9
06EC:  MOVFF  6A,FEA
06F0:  CLRF   FEF
....................  
....................       //sidl 
....................       ptr--; 
06F2:  MOVF   x69,W
06F4:  BTFSC  FD8.2
06F6:  DECF   x6A,F
06F8:  DECF   x69,F
....................       *ptr=(make8(id,0) << 5) & 0xE0; 
06FA:  MOVFF  69,FE9
06FE:  MOVFF  6A,FEA
0702:  MOVFF  64,00
0706:  SWAPF  00,F
0708:  RLCF   00,F
070A:  MOVLW  E0
070C:  ANDWF  00,F
070E:  MOVF   00,W
0710:  ANDLW  E0
0712:  MOVWF  FEF
....................  
....................       //sidh 
....................       ptr--; 
0714:  MOVF   x69,W
0716:  BTFSC  FD8.2
0718:  DECF   x6A,F
071A:  DECF   x69,F
....................       *ptr=(make8(id,0) >> 3) & 0x1F; 
071C:  MOVFF  69,FE9
0720:  MOVFF  6A,FEA
0724:  MOVFF  64,00
0728:  RRCF   00,F
072A:  RRCF   00,F
072C:  RRCF   00,F
072E:  MOVLW  1F
0730:  ANDWF  00,F
0732:  MOVF   00,W
0734:  ANDLW  1F
0736:  MOVWF  FEF
....................       *ptr|=(make8(id,1) << 5) & 0xE0; 
0738:  MOVFF  69,FE9
073C:  MOVFF  6A,FEA
0740:  MOVFF  65,00
0744:  SWAPF  00,F
0746:  RLCF   00,F
0748:  MOVLW  E0
074A:  ANDWF  00,F
074C:  MOVF   00,W
074E:  ANDLW  E0
0750:  IORWF  FEF,W
0752:  MOVWF  FEF
....................    } 
0754:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int * addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int * ptr; 
....................  
....................    ret=0; 
*
1B28:  CLRF   x64
1B2A:  CLRF   x63
1B2C:  CLRF   x62
1B2E:  CLRF   x61
....................    ptr=addr; 
1B30:  MOVFF  5F,66
1B34:  MOVFF  5E,65
....................  
....................    if (ext) { 
1B38:  MOVF   x60,F
1B3A:  BTFSC  FD8.2
1B3C:  BRA    1C50
....................       ret=*ptr;  //eidl 
1B3E:  MOVFF  65,FE9
1B42:  MOVFF  66,FEA
1B46:  CLRF   x64
1B48:  CLRF   x63
1B4A:  CLRF   x62
1B4C:  MOVFF  FEF,61
....................  
....................       ptr--;     //eidh 
1B50:  MOVF   x65,W
1B52:  BTFSC  FD8.2
1B54:  DECF   x66,F
1B56:  DECF   x65,F
....................       ret|=((unsigned int32)*ptr << 8); 
1B58:  MOVFF  65,FE9
1B5C:  MOVFF  66,FEA
1B60:  MOVF   FEF,W
1B62:  CLRF   x69
1B64:  CLRF   x68
1B66:  MOVWF  x67
1B68:  CLRF   00
1B6A:  MOVF   00,W
1B6C:  IORWF  x61,F
1B6E:  MOVF   x67,W
1B70:  IORWF  x62,F
1B72:  MOVF   x68,W
1B74:  IORWF  x63,F
1B76:  MOVF   x69,W
1B78:  IORWF  x64,F
....................  
....................       ptr--;     //sidl 
1B7A:  MOVF   x65,W
1B7C:  BTFSC  FD8.2
1B7E:  DECF   x66,F
1B80:  DECF   x65,F
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
1B82:  MOVFF  65,FE9
1B86:  MOVFF  66,FEA
1B8A:  MOVF   FEF,W
1B8C:  CLRF   x6A
1B8E:  CLRF   x69
1B90:  CLRF   x68
1B92:  MOVWF  x67
1B94:  MOVLW  03
1B96:  ANDWF  x67,F
1B98:  CLRF   x68
1B9A:  CLRF   x69
1B9C:  CLRF   x6A
1B9E:  CLRF   00
1BA0:  CLRF   01
1BA2:  MOVF   00,W
1BA4:  IORWF  x61,F
1BA6:  MOVF   01,W
1BA8:  IORWF  x62,F
1BAA:  MOVF   x67,W
1BAC:  IORWF  x63,F
1BAE:  MOVF   x68,W
1BB0:  IORWF  x64,F
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
1BB2:  MOVFF  65,FE9
1BB6:  MOVFF  66,FEA
1BBA:  MOVF   FEF,W
1BBC:  CLRF   x6A
1BBE:  CLRF   x69
1BC0:  CLRF   x68
1BC2:  MOVWF  x67
1BC4:  MOVLW  E0
1BC6:  ANDWF  x67,F
1BC8:  CLRF   x68
1BCA:  CLRF   x69
1BCC:  CLRF   x6A
1BCE:  CLRF   00
1BD0:  RLCF   x67,W
1BD2:  MOVWF  01
1BD4:  RLCF   x68,W
1BD6:  MOVWF  02
1BD8:  RLCF   x69,W
1BDA:  MOVWF  03
1BDC:  RLCF   01,F
1BDE:  RLCF   02,F
1BE0:  RLCF   03,F
1BE2:  RLCF   01,F
1BE4:  RLCF   02,F
1BE6:  RLCF   03,F
1BE8:  RLCF   01,F
1BEA:  RLCF   02,F
1BEC:  RLCF   03,F
1BEE:  RLCF   01,F
1BF0:  RLCF   02,F
1BF2:  RLCF   03,F
1BF4:  MOVLW  E0
1BF6:  ANDWF  01,F
1BF8:  MOVF   00,W
1BFA:  IORWF  x61,F
1BFC:  MOVF   01,W
1BFE:  IORWF  x62,F
1C00:  MOVF   02,W
1C02:  IORWF  x63,F
1C04:  MOVF   03,W
1C06:  IORWF  x64,F
....................  
....................       ptr--;     //sidh 
1C08:  MOVF   x65,W
1C0A:  BTFSC  FD8.2
1C0C:  DECF   x66,F
1C0E:  DECF   x65,F
....................       ret|=((unsigned int32)*ptr << 21); 
1C10:  MOVFF  65,FE9
1C14:  MOVFF  66,FEA
1C18:  MOVF   FEF,W
1C1A:  CLRF   x68
1C1C:  MOVWF  x67
1C1E:  CLRF   00
1C20:  CLRF   01
1C22:  RLCF   x67,W
1C24:  MOVWF  02
1C26:  RLCF   x68,W
1C28:  MOVWF  03
1C2A:  RLCF   02,F
1C2C:  RLCF   03,F
1C2E:  RLCF   02,F
1C30:  RLCF   03,F
1C32:  RLCF   02,F
1C34:  RLCF   03,F
1C36:  RLCF   02,F
1C38:  RLCF   03,F
1C3A:  MOVLW  E0
1C3C:  ANDWF  02,F
1C3E:  MOVF   00,W
1C40:  IORWF  x61,F
1C42:  MOVF   01,W
1C44:  IORWF  x62,F
1C46:  MOVF   02,W
1C48:  IORWF  x63,F
1C4A:  MOVF   03,W
1C4C:  IORWF  x64,F
....................  
....................    } 
1C4E:  BRA    1CF6
....................    else { 
....................       ptr-=2;    //sidl 
1C50:  MOVLW  02
1C52:  SUBWF  x65,F
1C54:  MOVLW  00
1C56:  SUBWFB x66,F
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
1C58:  MOVFF  65,FE9
1C5C:  MOVFF  66,FEA
1C60:  MOVF   FEF,W
1C62:  CLRF   x6A
1C64:  CLRF   x69
1C66:  CLRF   x68
1C68:  MOVWF  x67
1C6A:  MOVLW  E0
1C6C:  ANDWF  x67,F
1C6E:  CLRF   x68
1C70:  CLRF   x69
1C72:  CLRF   x6A
1C74:  RRCF   x6A,W
1C76:  MOVWF  x64
1C78:  RRCF   x69,W
1C7A:  MOVWF  x63
1C7C:  RRCF   x68,W
1C7E:  MOVWF  x62
1C80:  RRCF   x67,W
1C82:  MOVWF  x61
1C84:  RRCF   x64,F
1C86:  RRCF   x63,F
1C88:  RRCF   x62,F
1C8A:  RRCF   x61,F
1C8C:  RRCF   x64,F
1C8E:  RRCF   x63,F
1C90:  RRCF   x62,F
1C92:  RRCF   x61,F
1C94:  RRCF   x64,F
1C96:  RRCF   x63,F
1C98:  RRCF   x62,F
1C9A:  RRCF   x61,F
1C9C:  RRCF   x64,F
1C9E:  RRCF   x63,F
1CA0:  RRCF   x62,F
1CA2:  RRCF   x61,F
1CA4:  MOVLW  07
1CA6:  ANDWF  x64,F
....................  
....................       ptr--;     //sidh 
1CA8:  MOVF   x65,W
1CAA:  BTFSC  FD8.2
1CAC:  DECF   x66,F
1CAE:  DECF   x65,F
....................       ret|=((unsigned int32)*ptr << 3); 
1CB0:  MOVFF  65,FE9
1CB4:  MOVFF  66,FEA
1CB8:  MOVF   FEF,W
1CBA:  CLRF   x6A
1CBC:  CLRF   x69
1CBE:  CLRF   x68
1CC0:  MOVWF  x67
1CC2:  RLCF   x67,W
1CC4:  MOVWF  00
1CC6:  RLCF   x68,W
1CC8:  MOVWF  01
1CCA:  RLCF   x69,W
1CCC:  MOVWF  02
1CCE:  RLCF   x6A,W
1CD0:  MOVWF  03
1CD2:  RLCF   00,F
1CD4:  RLCF   01,F
1CD6:  RLCF   02,F
1CD8:  RLCF   03,F
1CDA:  RLCF   00,F
1CDC:  RLCF   01,F
1CDE:  RLCF   02,F
1CE0:  RLCF   03,F
1CE2:  MOVLW  F8
1CE4:  ANDWF  00,F
1CE6:  MOVF   00,W
1CE8:  IORWF  x61,F
1CEA:  MOVF   01,W
1CEC:  IORWF  x62,F
1CEE:  MOVF   02,W
1CF0:  IORWF  x63,F
1CF2:  MOVF   03,W
1CF4:  IORWF  x64,F
....................    } 
....................  
....................    return(ret); 
1CF6:  MOVFF  61,00
1CFA:  MOVFF  62,01
1CFE:  MOVFF  63,02
1D02:  MOVFF  64,03
1D06:  GOTO   230A (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int * data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int * txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
1DB0:  MOVLW  0F
1DB2:  MOVWF  x60
1DB4:  MOVLW  66
1DB6:  MOVWF  5F
....................  
....................     // find empty transmitter 
....................     //map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) { 
1DB8:  MOVLB  F
1DBA:  BTFSC  x40.3
1DBC:  BRA    1DCE
....................       CANCON.win=CAN_WIN_TX0; 
1DBE:  MOVLW  F1
1DC0:  ANDWF  F6F,W
1DC2:  IORLW  08
1DC4:  MOVWF  F6F
....................       port=0; 
1DC6:  MOVLB  0
1DC8:  CLRF   x61
....................    } 
1DCA:  BRA    1E02
1DCC:  MOVLB  F
....................    else if (!TXB1CON.txreq) { 
1DCE:  BTFSC  x30.3
1DD0:  BRA    1DE4
....................       CANCON.win=CAN_WIN_TX1; 
1DD2:  MOVLW  F1
1DD4:  ANDWF  F6F,W
1DD6:  IORLW  06
1DD8:  MOVWF  F6F
....................       port=1; 
1DDA:  MOVLW  01
1DDC:  MOVLB  0
1DDE:  MOVWF  x61
....................    } 
1DE0:  BRA    1E02
1DE2:  MOVLB  F
....................    else if (!TXB2CON.txreq) { 
1DE4:  BTFSC  x20.3
1DE6:  BRA    1DFA
....................       CANCON.win=CAN_WIN_TX2; 
1DE8:  MOVLW  F1
1DEA:  ANDWF  F6F,W
1DEC:  IORLW  04
1DEE:  MOVWF  F6F
....................       port=2; 
1DF0:  MOVLW  02
1DF2:  MOVLB  0
1DF4:  MOVWF  x61
....................    } 
1DF6:  BRA    1E02
1DF8:  MOVLB  F
....................    else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
1DFA:  MOVLW  00
1DFC:  MOVWF  01
1DFE:  BRA    1E78
1E00:  MOVLB  0
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
1E02:  MOVF   5B,W
1E04:  ANDLW  03
1E06:  MOVWF  00
1E08:  MOVLW  FC
1E0A:  ANDWF  F60,W
1E0C:  IORWF  00,W
1E0E:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
1E10:  MOVLW  0F
1E12:  MOVWF  x63
1E14:  MOVLW  64
1E16:  MOVWF  x62
1E18:  MOVFF  57,67
1E1C:  MOVFF  56,66
1E20:  MOVFF  55,65
1E24:  MOVFF  54,64
1E28:  MOVFF  5C,68
1E2C:  CALL   0626
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
1E30:  MOVFF  5A,F65
....................    TXBaDLC.rtr=rtr; 
1E34:  BCF    F65.6
1E36:  BTFSC  5D.0
1E38:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
1E3A:  CLRF   5E
1E3C:  MOVF   5A,W
1E3E:  SUBWF  5E,W
1E40:  BC    1E6A
....................       *txd0=*data; 
1E42:  MOVFF  58,FE9
1E46:  MOVFF  59,FEA
1E4A:  MOVFF  FEF,64
1E4E:  MOVFF  60,FEA
1E52:  MOVFF  5F,FE9
1E56:  MOVFF  64,FEF
....................       txd0++; 
1E5A:  INCF   5F,F
1E5C:  BTFSC  FD8.2
1E5E:  INCF   x60,F
....................       data++; 
1E60:  INCF   58,F
1E62:  BTFSC  FD8.2
1E64:  INCF   59,F
1E66:  INCF   5E,F
1E68:  BRA    1E3C
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
1E6A:  BSF    F60.3
....................  
....................    CANCON.win=CAN_WIN_RX0; 
1E6C:  MOVLW  F1
1E6E:  ANDWF  F6F,W
1E70:  MOVWF  F6F
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
1E72:  MOVLW  01
1E74:  MOVWF  01
1E76:  MOVLB  F
1E78:  MOVLB  0
1E7A:  GOTO   2560 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Returns: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 & id, unsigned int * data, unsigned int & len, struct rx_stat & stat) 
.................... { 
....................     unsigned int i; 
....................     unsigned int * ptr; 
....................  
....................     if (RXB0CON.rxful) { 
*
2278:  BTFSS  F60.7
227A:  BRA    22AA
....................         CANCON.win=CAN_WIN_RX0; 
227C:  MOVLW  F1
227E:  ANDWF  F6F,W
2280:  MOVWF  F6F
....................         stat.buffer=0; 
2282:  BCF    22.4
....................  
....................         CAN_INT_RXB0IF=0; 
2284:  BCF    FA4.0
....................  
....................         stat.err_ovfl=COMSTAT.rx0ovfl; 
2286:  BCF    22.0
2288:  BTFSC  F74.7
228A:  BSF    22.0
....................         COMSTAT.rx0ovfl=0; 
228C:  BCF    F74.7
....................  
....................         if (RXB0CON.rxb0dben) { 
228E:  BTFSS  F60.2
2290:  BRA    22A8
....................          stat.filthit=RXB0CON.filthit0; 
2292:  MOVLW  00
2294:  BTFSC  F60.0
2296:  MOVLW  01
2298:  ANDLW  07
229A:  MOVWF  00
229C:  BCF    FD8.0
229E:  RLCF   00,F
22A0:  MOVLW  F1
22A2:  ANDWF  22,W
22A4:  IORWF  00,W
22A6:  MOVWF  22
....................         } 
....................     } 
22A8:  BRA    22E2
....................     else if ( RXB1CON.rxful ) 
22AA:  MOVLB  F
22AC:  BTFSS  x50.7
22AE:  BRA    22DA
....................     { 
....................         CANCON.win=CAN_WIN_RX1; 
22B0:  MOVLW  F1
22B2:  ANDWF  F6F,W
22B4:  IORLW  0A
22B6:  MOVWF  F6F
....................         stat.buffer=1; 
22B8:  BSF    22.4
....................  
....................         CAN_INT_RXB1IF=0; 
22BA:  BCF    FA4.1
....................  
....................         stat.err_ovfl=COMSTAT.rx1ovfl; 
22BC:  BCF    22.0
22BE:  BTFSC  F74.6
22C0:  BSF    22.0
....................         COMSTAT.rx1ovfl=0; 
22C2:  BCF    F74.6
....................  
....................         stat.filthit=RXB1CON.filthit; 
22C4:  MOVF   x50,W
22C6:  ANDLW  07
22C8:  ANDLW  07
22CA:  MOVWF  00
22CC:  BCF    FD8.0
22CE:  RLCF   00,F
22D0:  MOVLW  F1
22D2:  ANDWF  22,W
22D4:  IORWF  00,W
22D6:  MOVWF  22
....................     } 
22D8:  BRA    22E0
....................     else { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
22DA:  MOVLW  00
22DC:  MOVWF  01
22DE:  BRA    2374
22E0:  MOVLB  0
....................     } 
....................  
....................     len = RXBaDLC.dlc; 
22E2:  MOVF   F65,W
22E4:  ANDLW  0F
22E6:  MOVWF  2F
....................     stat.rtr=RXBaDLC.rtr; 
22E8:  BCF    22.5
22EA:  BTFSC  F65.6
22EC:  BSF    22.5
....................  
....................     stat.ext=TXRXBaSIDL.ext; 
22EE:  BCF    22.6
22F0:  BTFSC  F62.3
22F2:  BSF    22.6
....................     id=can_get_id(TXRXBaID,stat.ext); 
22F4:  MOVLW  00
22F6:  BTFSC  22.6
22F8:  MOVLW  01
22FA:  MOVWF  57
22FC:  MOVLW  0F
22FE:  MOVWF  5F
2300:  MOVLW  64
2302:  MOVWF  5E
2304:  MOVFF  57,60
2308:  BRA    1B28
230A:  MOVFF  03,26
230E:  MOVFF  02,25
2312:  MOVFF  01,24
2316:  MOVFF  00,23
....................  
....................     ptr = &TXRXBaD0; 
231A:  MOVLW  0F
231C:  MOVWF  56
231E:  MOVLW  66
2320:  MOVWF  55
....................     for ( i = 0; i < len; i++ ) { 
2322:  CLRF   54
2324:  MOVF   2F,W
2326:  SUBWF  54,W
2328:  BC    2352
....................         *data = *ptr; 
232A:  MOVFF  55,FE9
232E:  MOVFF  56,FEA
2332:  MOVFF  FEF,59
2336:  MOVFF  53,FEA
233A:  MOVFF  52,FE9
233E:  MOVFF  59,FEF
....................         data++; 
2342:  INCF   52,F
2344:  BTFSC  FD8.2
2346:  INCF   53,F
....................         ptr++; 
2348:  INCF   55,F
234A:  BTFSC  FD8.2
234C:  INCF   56,F
234E:  INCF   54,F
2350:  BRA    2324
....................     } 
....................  
....................     // return to default addressing 
....................     CANCON.win=CAN_WIN_RX0; 
2352:  MOVLW  F1
2354:  ANDWF  F6F,W
2356:  MOVWF  F6F
....................  
....................     stat.inv=CAN_INT_IRXIF; 
2358:  BCF    22.7
235A:  BTFSC  FA4.7
235C:  BSF    22.7
....................     CAN_INT_IRXIF = 0; 
235E:  BCF    FA4.7
....................  
....................     if (stat.buffer) { 
2360:  BTFSS  22.4
2362:  BRA    236C
....................       RXB1CON.rxful=0; 
2364:  MOVLB  F
2366:  BCF    x50.7
....................     } 
2368:  BRA    2370
236A:  MOVLB  0
....................     else { 
....................       RXB0CON.rxful=0; 
236C:  BCF    F60.7
236E:  MOVLB  F
....................     } 
....................  
....................     #if CAN_DO_DEBUG 
....................        can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................        can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................        if ((len)&&(!stat.rtr)) { 
....................           data-=len; 
....................           can_debug("\r\n    DATA = "); 
....................           for (i=0;i<len;i++) { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................           } 
....................        } 
....................        can_debug("\r\n"); 
....................     #endif 
....................  
....................     return(1); 
2370:  MOVLW  01
2372:  MOVWF  01
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... #include <MAX31855.c> 
.................... #define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_1  (SPI_L_TO_H)  
.................... #define SPI_MODE_2  (SPI_H_TO_L)  
.................... #define SPI_MODE_3  (SPI_H_TO_L | SPI_XMIT_L_TO_H)  
.................... #define CS PIN_B6 
....................   
.................... //#use spi(MASTER, SPI_MODE_1, DO=PIN_B4, CLK=PIN_B5, BITS = 8, LSB_FIRST, SAMPLE_RISE, baud = 100000, stream=MAX31855)  
.................... //#use spi(SPI1, MASTER, baud=100000, MODE=0, bits=8, stream=MAX31855)  
.................... #use SPI( DI = PIN_B4, CLK = PIN_B5, baud = 100000, BITS = 8, MODE =0, MSB_FIRST, SAMPLE_RISE, stream=MAX31855 ) //  
*
08E6:  MOVF   x72,W
08E8:  SUBLW  08
08EA:  BZ    08F4
08EC:  MOVWF  x73
08EE:  RLCF   x71,F
08F0:  DECFSZ x73,F
08F2:  BRA    08EE
08F4:  BSF    F93.4
08F6:  BCF    F93.5
08F8:  BCF    F8A.5
08FA:  MOVFF  72,73
08FE:  BSF    F8A.5
0900:  MOVLW  07
0902:  MOVWF  x74
0904:  DECFSZ x74,F
0906:  BRA    0904
0908:  RLCF   01,F
090A:  BTFSS  F81.4
090C:  BCF    01.0
090E:  BTFSC  F81.4
0910:  BSF    01.0
0912:  BCF    F8A.5
0914:  MOVLW  08
0916:  MOVWF  x74
0918:  DECFSZ x74,F
091A:  BRA    0918
091C:  DECFSZ x73,F
091E:  BRA    08FE
0920:  RETURN 0
.................... const int16 NegativeK[150]={  0,  39,  79, 118, 157, 197, 236, 275, 314, 353,  
....................                       392, 431, 470, 508, 547, 586, 624, 663, 701, 739,  
....................                       778, 816, 854, 892, 930, 968,1006,1043,1081,1119,  
....................                      1156,1194,1231,1268,1305,1343,1380,1417,1453,1490,  
....................                      1527,1564,1600,1637,1673,1709,1745,1782,1818,1854,  
....................                      1889,1925,1961,1996,2032,2067,2103,2138,2173,2208,  
....................                      2243,2278,2312,2347,2382,2416,2450,2485,2519,2553,  
....................                      2587,2620,2654,2688,2721,2755,2788,2821,2854,2887,  
....................                      2920,2953,2986,3018,3050,3083,3115,3147,3179,3211,  
....................                      3243,3274,3306,3337,3368,3400,3431,3462,3492,3523,  
....................                      3554,3584,3614,3645,3675,3705,3734,3764,3794,3823,  
....................                      3852,3882,3911,3939,3968,3997,4025,4054,4082,4110,  
....................                      4138,4166,4194,4221,4249,4276,4303,4330,4357,4384,  
....................                      4411,4437,4463,4490,4516,4542,4567,4593,4618,4644,  
....................                      4669,4694,4719,4744,4768,4793,4817,4841,4865,4889};  
....................  
.................... const int16 PositiveK[150]={  0,  39,  79, 119, 158, 198, 238, 277, 317, 357,  
....................                       397, 437, 477, 517, 557, 597, 637, 677, 718, 758,  
....................                       798, 838, 879, 919, 960,1000,1041,1081,1122,1163,  
....................                      1203,1244,1285,1326,1366,1407,1448,1489,1530,1571,  
....................                      1612,1653,1694,1735,1776,1817,1858,1899,1941,1982,  
....................                      2023,2064,2106,2147,2188,2230,2271,2312,2354,2395,  
....................                      2436,2478,2519,2561,2602,2644,2685,2727,2768,2810,  
....................                      2851,2893,2934,2976,3017,3059,3100,3142,3184,3225,  
....................                      3267,3308,3350,3391,3433,3474,3516,3557,3599,3640,  
....................                      3682,3723,3765,3806,3848,3889,3931,3972,4013,4055,  
....................                      4096,4138,4179,4220,4262,4303,4344,4385,4427,4468,  
....................                      4509,4550,4591,4633,4674,4715,4756,4797,4838,4879,  
....................                      4920,4961,5002,5043,5084,5124,5165,5206,5247,5288,  
....................                      5328,5369,5410,5450,5491,5532,5572,5613,5653,5694,  
....................                      5735,5775,5815,5856,5896,5937,5977,6017,6058,6098};  
....................  
....................  
.................... static int8 spival[4];  
.................... //int16 Count=0;  
.................... /*******************************************************************************  
.................... //Read SPI data  
.................... *******************************************************************************/   
.................... /* 
.................... void Read4Byte() 
.................... { 
.................... //spi_xfer(); 
....................  
.................... spival[3] = spi_xfer(SPI_1,0); 
.................... spival[2] = spi_xfer(SPI_1,0); 
.................... spival[1] = spi_xfer(SPI_1,0); 
.................... spival[0] = spi_xfer(SPI_1,0); 
....................  
.................... } 
.................... */ 
....................  
.................... void readMAX()  
.................... {  
....................    spi_xfer(MAX31855,0); //switches the stream to mode 2      
0922:  CLRF   x71
0924:  MOVLW  08
0926:  MOVWF  x72
0928:  RCALL  08E6
....................    output_low(CS);  
092A:  BCF    F93.6
092C:  BCF    F8A.6
....................    //delay_us(10); 
....................    spival[3]=spi_xfer(MAX31855,0);  
092E:  CLRF   x71
0930:  MOVLW  08
0932:  MOVWF  x72
0934:  RCALL  08E6
0936:  MOVF   01,W
0938:  MOVFF  01,19
....................    delay_us(10); 
093C:  MOVLW  10
093E:  MOVWF  00
0940:  DECFSZ 00,F
0942:  BRA    0940
0944:  NOP   
....................    spival[2]=spi_xfer(MAX31855,0); 
0946:  CLRF   x71
0948:  MOVLW  08
094A:  MOVWF  x72
094C:  RCALL  08E6
094E:  MOVF   01,W
0950:  MOVFF  01,18
....................     delay_us(10); 
0954:  MOVLW  10
0956:  MOVWF  00
0958:  DECFSZ 00,F
095A:  BRA    0958
095C:  NOP   
....................    spival[1]=spi_xfer(MAX31855,0); 
095E:  CLRF   x71
0960:  MOVLW  08
0962:  MOVWF  x72
0964:  RCALL  08E6
0966:  MOVF   01,W
0968:  MOVFF  01,17
....................     delay_us(10); 
096C:  MOVLW  10
096E:  MOVWF  00
0970:  DECFSZ 00,F
0972:  BRA    0970
0974:  NOP   
....................    spival[0]=spi_xfer(MAX31855,0);  
0976:  CLRF   x71
0978:  MOVLW  08
097A:  MOVWF  x72
097C:  RCALL  08E6
097E:  MOVF   01,W
0980:  MOVFF  01,16
....................   delay_us(10); 
0984:  MOVLW  10
0986:  MOVWF  00
0988:  DECFSZ 00,F
098A:  BRA    0988
098C:  NOP   
....................    output_high(CS);  
098E:  BCF    F93.6
0990:  BSF    F8A.6
0992:  RETURN 0
.................... }  
....................  
.................... /* 
.................... void readMAX()  
.................... {  
....................       output_low(CS);  
....................       delay_us(10);  
....................       spival[3]=spi_read(0);  
....................       delay_us(10);  
....................       spival[2]=spi_read(0);  
....................       delay_us(10);  
....................       spival[1]=spi_read(0);  
....................       delay_us(10);  
....................       spival[0]=spi_read(0);  
....................       delay_us(10);  
....................       output_high(CS);  
....................  
.................... } 
.................... */ 
.................... /*******************************************************************************  
.................... //Fault detection.  
.................... //Returns >0 if FAULT. If necessary do a bitwise analisys to check fault source  
.................... *******************************************************************************/  
.................... int tempFault()  
*
0A0C:  BCF    x71.0
0A0E:  BCF    x71.1
0A10:  BCF    x71.2
0A12:  BCF    x71.3
.................... {  
....................       int1 Fvdd=0,Fgnd=0,Fopen=0,fault=0;  
....................    
....................       fault=spival[2]&0x01; // pelos menos uma falha  
0A14:  MOVF   18,W
0A16:  ANDLW  01
0A18:  BCF    x71.3
0A1A:  BTFSC  FE8.0
0A1C:  BSF    x71.3
....................       Fvdd=(spival[0]>>2)&0x01;  
0A1E:  RRCF   16,W
0A20:  MOVWF  00
0A22:  RRCF   00,F
0A24:  MOVLW  3F
0A26:  ANDWF  00,F
0A28:  MOVF   00,W
0A2A:  ANDLW  01
0A2C:  BCF    x71.0
0A2E:  BTFSC  FE8.0
0A30:  BSF    x71.0
....................       Fgnd=(spival[0]>>1)&0x01;  
0A32:  BCF    FD8.0
0A34:  RRCF   16,W
0A36:  ANDLW  01
0A38:  BCF    x71.1
0A3A:  BTFSC  FE8.0
0A3C:  BSF    x71.1
....................       Fopen=spival[0]&0x01;  
0A3E:  MOVF   16,W
0A40:  ANDLW  01
0A42:  BCF    x71.2
0A44:  BTFSC  FE8.0
0A46:  BSF    x71.2
....................        
....................       return (fault*1+Fvdd*2,Fgnd*4,Fopen*8);  
0A48:  MOVLW  00
0A4A:  BTFSC  x71.3
0A4C:  MOVLW  01
0A4E:  MOVWF  x72
0A50:  MOVLW  00
0A52:  BTFSC  x71.0
0A54:  MOVLW  01
0A56:  MOVWF  00
0A58:  BCF    FD8.0
0A5A:  RLCF   00,F
0A5C:  MOVF   00,W
0A5E:  ADDWF  x72,W
0A60:  MOVLW  00
0A62:  BTFSC  x71.1
0A64:  MOVLW  01
0A66:  MULLW  04
0A68:  MOVF   FF3,W
0A6A:  MOVLW  00
0A6C:  BTFSC  x71.2
0A6E:  MOVLW  01
0A70:  MULLW  08
0A72:  MOVFF  FF3,01
0A76:  GOTO   10E8 (RETURN)
.................... }  
....................  
.................... /*******************************************************************************  
.................... //Read thermocouple temperature  
.................... //Returns returns signed temperature in C approximately  
.................... *******************************************************************************/  
.................... float readExtTemp()  
*
0CC6:  CLRF   x74
0CC8:  CLRF   x73
0CCA:  CLRF   x78
0CCC:  CLRF   x77
0CCE:  CLRF   x76
0CD0:  CLRF   x75
.................... {  
....................       int16 temp1=0;  
....................       float aux=0;  
....................    
.................... //spival[3]=0x01;  
.................... //spival[2]=0x90;  
.................... //Count++;  
....................  
....................       temp1=make16(spival[3],spival[2]);  
0CD2:  MOVFF  19,74
0CD6:  MOVFF  18,73
.................... //temp1-=Count;  
....................  
.................... //fprintf(lcd_putc,"REXT:%LX , ",Temp1);  
....................      
....................       if(!bit_test(temp1,15))  
0CDA:  BTFSC  x74.7
0CDC:  BRA    0D34
....................       {  
....................          temp1>>=2;  
0CDE:  RRCF   x74,F
0CE0:  RRCF   x73,F
0CE2:  RRCF   x74,F
0CE4:  RRCF   x73,F
0CE6:  MOVLW  3F
0CE8:  ANDWF  x74,F
.................... //fprintf(lcd_putc,"SR+EXT:%LX , ",Temp1);  
....................          aux=(temp1/4.00);  
0CEA:  MOVFF  74,7A
0CEE:  MOVFF  73,79
0CF2:  RCALL  0994
0CF4:  MOVFF  03,7C
0CF8:  MOVFF  02,7B
0CFC:  MOVFF  01,7A
0D00:  MOVFF  00,79
0D04:  CLRF   x80
0D06:  CLRF   x7F
0D08:  CLRF   x7E
0D0A:  MOVLW  81
0D0C:  MOVWF  x7D
0D0E:  RCALL  0A7A
0D10:  MOVFF  03,78
0D14:  MOVFF  02,77
0D18:  MOVFF  01,76
0D1C:  MOVFF  00,75
.................... //fprintf(lcd_putc,"Ext+C:%3.2f, ",aux);  
....................             return aux;  
0D20:  MOVFF  75,00
0D24:  MOVFF  76,01
0D28:  MOVFF  77,02
0D2C:  MOVFF  78,03
0D30:  BRA    0DC0
....................       }  
0D32:  BRA    0DC0
....................       else  
....................       {  
....................          temp1=~temp1;  
0D34:  COMF   x73,F
0D36:  COMF   x74,F
....................          temp1>>=2;  
0D38:  RRCF   x74,F
0D3A:  RRCF   x73,F
0D3C:  RRCF   x74,F
0D3E:  RRCF   x73,F
0D40:  MOVLW  3F
0D42:  ANDWF  x74,F
....................          temp1+=1;  
0D44:  MOVLW  01
0D46:  ADDWF  x73,F
0D48:  MOVLW  00
0D4A:  ADDWFC x74,F
.................... //fprintf(lcd_putc,"SR-EXT:%LX , ",Temp1);  
....................          aux=((temp1/4.00)*-1.00);  
0D4C:  MOVFF  74,7A
0D50:  MOVFF  73,79
0D54:  RCALL  0994
0D56:  MOVFF  03,7C
0D5A:  MOVFF  02,7B
0D5E:  MOVFF  01,7A
0D62:  MOVFF  00,79
0D66:  CLRF   x80
0D68:  CLRF   x7F
0D6A:  CLRF   x7E
0D6C:  MOVLW  81
0D6E:  MOVWF  x7D
0D70:  RCALL  0A7A
0D72:  MOVFF  03,7C
0D76:  MOVFF  02,7B
0D7A:  MOVFF  01,7A
0D7E:  MOVFF  00,79
0D82:  MOVFF  03,80
0D86:  MOVFF  02,7F
0D8A:  MOVFF  01,7E
0D8E:  MOVFF  00,7D
0D92:  CLRF   x84
0D94:  CLRF   x83
0D96:  MOVLW  80
0D98:  MOVWF  x82
0D9A:  MOVLW  7F
0D9C:  MOVWF  x81
0D9E:  RCALL  0BD4
0DA0:  MOVFF  03,78
0DA4:  MOVFF  02,77
0DA8:  MOVFF  01,76
0DAC:  MOVFF  00,75
....................  
.................... //fprintf(lcd_putc,"RAW Ext-C:%3.2f, ",aux);  
....................             return aux;  
0DB0:  MOVFF  75,00
0DB4:  MOVFF  76,01
0DB8:  MOVFF  77,02
0DBC:  MOVFF  78,03
....................       }  
0DC0:  GOTO   1106 (RETURN)
.................... }  
....................  
.................... /*******************************************************************************  
.................... //Read internal temperature  
.................... //Returns returns signed temperature in C approximately  
.................... *******************************************************************************/  
.................... float readIntTemp()  
*
131C:  CLRF   x64
131E:  CLRF   x63
1320:  CLRF   x68
1322:  CLRF   x67
1324:  CLRF   x66
1326:  CLRF   x65
.................... {  
....................     int16 temp2=0;  
....................    float aux=0;  
....................        
....................    temp2=make16(spival[1],spival[0]);  
1328:  MOVFF  17,64
132C:  MOVFF  16,63
.................... //fprintf(lcd_putc,"RINT:%LX , ",Temp2);  
....................  
....................    if(!bit_test(temp2,15))  
1330:  BTFSC  x64.7
1332:  BRA    1396
....................    {  
....................       temp2>>=4;  
1334:  RRCF   x64,F
1336:  RRCF   x63,F
1338:  RRCF   x64,F
133A:  RRCF   x63,F
133C:  RRCF   x64,F
133E:  RRCF   x63,F
1340:  RRCF   x64,F
1342:  RRCF   x63,F
1344:  MOVLW  0F
1346:  ANDWF  x64,F
.................... //fprintf(lcd_putc,"SR+INT:%LX , ",Temp2);  
....................       aux=(temp2/16.00);  
1348:  MOVFF  64,7A
134C:  MOVFF  63,79
1350:  CALL   0994
1354:  MOVFF  03,7C
1358:  MOVFF  02,7B
135C:  MOVFF  01,7A
1360:  MOVFF  00,79
1364:  CLRF   x80
1366:  CLRF   x7F
1368:  CLRF   x7E
136A:  MOVLW  83
136C:  MOVWF  x7D
136E:  CALL   0A7A
1372:  MOVFF  03,68
1376:  MOVFF  02,67
137A:  MOVFF  01,66
137E:  MOVFF  00,65
.................... //fprintf(lcd_putc,"Int+C:%3.2f\r\n",aux);  
....................          return aux;  
1382:  MOVFF  65,00
1386:  MOVFF  66,01
138A:  MOVFF  67,02
138E:  MOVFF  68,03
1392:  BRA    1430
....................     }   
1394:  BRA    1430
....................    else  
....................    {  
....................       temp2=~temp2;  
1396:  COMF   x63,F
1398:  COMF   x64,F
....................       temp2>>=4;  
139A:  RRCF   x64,F
139C:  RRCF   x63,F
139E:  RRCF   x64,F
13A0:  RRCF   x63,F
13A2:  RRCF   x64,F
13A4:  RRCF   x63,F
13A6:  RRCF   x64,F
13A8:  RRCF   x63,F
13AA:  MOVLW  0F
13AC:  ANDWF  x64,F
....................       temp2+=1;  
13AE:  MOVLW  01
13B0:  ADDWF  x63,F
13B2:  MOVLW  00
13B4:  ADDWFC x64,F
.................... //fprintf(lcd_putc,"SR-INT:%LX , ",Temp2);  
....................       aux=((temp2/16.00)*-1.00);  
13B6:  MOVFF  64,7A
13BA:  MOVFF  63,79
13BE:  CALL   0994
13C2:  MOVFF  03,7C
13C6:  MOVFF  02,7B
13CA:  MOVFF  01,7A
13CE:  MOVFF  00,79
13D2:  CLRF   x80
13D4:  CLRF   x7F
13D6:  CLRF   x7E
13D8:  MOVLW  83
13DA:  MOVWF  x7D
13DC:  CALL   0A7A
13E0:  MOVFF  03,6C
13E4:  MOVFF  02,6B
13E8:  MOVFF  01,6A
13EC:  MOVFF  00,69
13F0:  MOVFF  03,80
13F4:  MOVFF  02,7F
13F8:  MOVFF  01,7E
13FC:  MOVFF  00,7D
1400:  CLRF   x84
1402:  CLRF   x83
1404:  MOVLW  80
1406:  MOVWF  x82
1408:  MOVLW  7F
140A:  MOVWF  x81
140C:  CALL   0BD4
1410:  MOVFF  03,68
1414:  MOVFF  02,67
1418:  MOVFF  01,66
141C:  MOVFF  00,65
.................... //fprintf(lcd_putc,"RAW Int-C:%3.2f\r\n",aux);  
....................          return aux;  
1420:  MOVFF  65,00
1424:  MOVFF  66,01
1428:  MOVFF  67,02
142C:  MOVFF  68,03
....................    }   
1430:  GOTO   146A (RETURN)
.................... }  
....................  
.................... float PreFilter()  
*
10BC:  CLRF   x6F
10BE:  BCF    x70.0
.................... {  
.................... float Raw_TC_Temp[3]={0.00,0.00,0.00};  
*
10A4:  CLRF   x63
10A6:  CLRF   x64
10A8:  CLRF   x65
10AA:  CLRF   x66
10AC:  CLRF   x67
10AE:  CLRF   x68
10B0:  CLRF   x69
10B2:  CLRF   x6A
10B4:  CLRF   x6B
10B6:  CLRF   x6C
10B8:  CLRF   x6D
10BA:  CLRF   x6E
.................... int Raw_Temp_Index=0;  
.................... int1 Temp_Stable=0;  
....................         
....................    while(Temp_Stable==0)  
*
10C0:  BTFSC  x70.0
10C2:  BRA    1292
....................    {  
....................       Raw_TC_Temp[0]=0.00;  
10C4:  CLRF   x66
10C6:  CLRF   x65
10C8:  CLRF   x64
10CA:  CLRF   x63
....................       Raw_TC_Temp[1]=0.00;  
10CC:  CLRF   x6A
10CE:  CLRF   x69
10D0:  CLRF   x68
10D2:  CLRF   x67
....................       Raw_TC_Temp[2]=0.00;  
10D4:  CLRF   x6E
10D6:  CLRF   x6D
10D8:  CLRF   x6C
10DA:  CLRF   x6B
....................       Raw_Temp_Index=0;  
10DC:  CLRF   x6F
....................  
....................       while(Raw_Temp_Index<3)  
10DE:  MOVF   x6F,W
10E0:  SUBLW  02
10E2:  BNC   112A
....................       {  
....................        do{readMAX();}while(tempFault()!=0);  
10E4:  RCALL  0922
10E6:  BRA    0A0C
10E8:  MOVF   01,F
10EA:  BNZ   10E4
....................       Raw_TC_Temp[Raw_Temp_Index]=readExtTemp();  
10EC:  MOVF   x6F,W
10EE:  MULLW  04
10F0:  MOVF   FF3,W
10F2:  CLRF   03
10F4:  ADDLW  63
10F6:  MOVWF  01
10F8:  MOVLW  00
10FA:  ADDWFC 03,F
10FC:  MOVFF  01,71
1100:  MOVFF  03,72
1104:  BRA    0CC6
1106:  MOVFF  72,FEA
110A:  MOVFF  71,FE9
110E:  MOVFF  00,FEF
1112:  MOVFF  01,FEC
1116:  MOVFF  02,FEC
111A:  MOVFF  03,FEC
.................... //Raw_TC_Temp[Raw_Temp_Index]=-70.00;               // DEBUG  
....................       Raw_Temp_Index++;  
111E:  INCF   x6F,F
....................       delay_ms(100);  
1120:  MOVLW  64
1122:  MOVWF  x71
1124:  CALL   04C4
1128:  BRA    10DE
....................       }  
....................       if((abs(Raw_TC_Temp[0]-Raw_TC_Temp[1])<1.25)&&(abs(Raw_TC_Temp[1]-Raw_TC_Temp[2])<1.25)&&(abs(Raw_TC_Temp[0]-Raw_TC_Temp[2])<1.25))  
112A:  BSF    FD8.1
112C:  MOVFF  66,78
1130:  MOVFF  65,77
1134:  MOVFF  64,76
1138:  MOVFF  63,75
113C:  MOVFF  6A,7C
1140:  MOVFF  69,7B
1144:  MOVFF  68,7A
1148:  MOVFF  67,79
114C:  RCALL  0DC4
114E:  MOVFF  03,74
1152:  MOVFF  02,73
1156:  MOVFF  01,72
115A:  MOVFF  00,71
115E:  MOVFF  00,00
1162:  MOVFF  01,01
1166:  MOVFF  02,02
116A:  MOVFF  03,03
116E:  BCF    01.7
1170:  MOVFF  03,74
1174:  MOVFF  02,73
1178:  MOVFF  01,72
117C:  MOVFF  00,71
1180:  MOVFF  03,78
1184:  MOVFF  02,77
1188:  MOVFF  01,76
118C:  MOVFF  00,75
1190:  CLRF   x7C
1192:  CLRF   x7B
1194:  MOVLW  20
1196:  MOVWF  x7A
1198:  MOVLW  7F
119A:  MOVWF  x79
119C:  RCALL  102E
119E:  BTFSS  FD8.0
11A0:  BRA    1290
11A2:  BSF    FD8.1
11A4:  MOVFF  6A,78
11A8:  MOVFF  69,77
11AC:  MOVFF  68,76
11B0:  MOVFF  67,75
11B4:  MOVFF  6E,7C
11B8:  MOVFF  6D,7B
11BC:  MOVFF  6C,7A
11C0:  MOVFF  6B,79
11C4:  RCALL  0DC4
11C6:  MOVFF  03,74
11CA:  MOVFF  02,73
11CE:  MOVFF  01,72
11D2:  MOVFF  00,71
11D6:  MOVFF  00,00
11DA:  MOVFF  01,01
11DE:  MOVFF  02,02
11E2:  MOVFF  03,03
11E6:  BCF    01.7
11E8:  MOVFF  03,74
11EC:  MOVFF  02,73
11F0:  MOVFF  01,72
11F4:  MOVFF  00,71
11F8:  MOVFF  03,78
11FC:  MOVFF  02,77
1200:  MOVFF  01,76
1204:  MOVFF  00,75
1208:  CLRF   x7C
120A:  CLRF   x7B
120C:  MOVLW  20
120E:  MOVWF  x7A
1210:  MOVLW  7F
1212:  MOVWF  x79
1214:  RCALL  102E
1216:  BNC   1290
1218:  BSF    FD8.1
121A:  MOVFF  66,78
121E:  MOVFF  65,77
1222:  MOVFF  64,76
1226:  MOVFF  63,75
122A:  MOVFF  6E,7C
122E:  MOVFF  6D,7B
1232:  MOVFF  6C,7A
1236:  MOVFF  6B,79
123A:  RCALL  0DC4
123C:  MOVFF  03,74
1240:  MOVFF  02,73
1244:  MOVFF  01,72
1248:  MOVFF  00,71
124C:  MOVFF  00,00
1250:  MOVFF  01,01
1254:  MOVFF  02,02
1258:  MOVFF  03,03
125C:  BCF    01.7
125E:  MOVFF  03,74
1262:  MOVFF  02,73
1266:  MOVFF  01,72
126A:  MOVFF  00,71
126E:  MOVFF  03,78
1272:  MOVFF  02,77
1276:  MOVFF  01,76
127A:  MOVFF  00,75
127E:  CLRF   x7C
1280:  CLRF   x7B
1282:  MOVLW  20
1284:  MOVWF  x7A
1286:  MOVLW  7F
1288:  MOVWF  x79
128A:  RCALL  102E
128C:  BNC   1290
....................       Temp_Stable=1;  
128E:  BSF    x70.0
1290:  BRA    10C0
....................    }  
.................... //fprintf(lcd_putc,"RAW1:%3.2f - RAW2:%3.2f - RAW3:%3.2f \r\n",Raw_TC_Temp[0],Raw_TC_Temp[1],Raw_TC_Temp[2]);  
....................    return((Raw_TC_Temp[0]+Raw_TC_Temp[1]+Raw_TC_Temp[2])/3.00);  
1292:  BCF    FD8.1
1294:  MOVFF  66,78
1298:  MOVFF  65,77
129C:  MOVFF  64,76
12A0:  MOVFF  63,75
12A4:  MOVFF  6A,7C
12A8:  MOVFF  69,7B
12AC:  MOVFF  68,7A
12B0:  MOVFF  67,79
12B4:  RCALL  0DC4
12B6:  MOVFF  03,74
12BA:  MOVFF  02,73
12BE:  MOVFF  01,72
12C2:  MOVFF  00,71
12C6:  BCF    FD8.1
12C8:  MOVFF  03,78
12CC:  MOVFF  02,77
12D0:  MOVFF  01,76
12D4:  MOVFF  00,75
12D8:  MOVFF  6E,7C
12DC:  MOVFF  6D,7B
12E0:  MOVFF  6C,7A
12E4:  MOVFF  6B,79
12E8:  RCALL  0DC4
12EA:  MOVFF  03,74
12EE:  MOVFF  02,73
12F2:  MOVFF  01,72
12F6:  MOVFF  00,71
12FA:  MOVFF  03,7C
12FE:  MOVFF  02,7B
1302:  MOVFF  01,7A
1306:  MOVFF  00,79
130A:  CLRF   x80
130C:  CLRF   x7F
130E:  MOVLW  40
1310:  MOVWF  x7E
1312:  MOVLW  80
1314:  MOVWF  x7D
1316:  CALL   0A7A
131A:  RETURN 0
.................... }  
....................  
.................... float Linearized_TC()  
*
1434:  CLRF   55
1436:  CLRF   54
1438:  CLRF   53
143A:  CLRF   52
143C:  CLRF   59
143E:  CLRF   58
1440:  CLRF   57
1442:  CLRF   56
1444:  CLRF   5D
1446:  CLRF   5C
1448:  CLRF   5B
144A:  CLRF   5A
144C:  CLRF   x61
144E:  CLRF   x60
1450:  CLRF   5F
1452:  CLRF   5E
1454:  CLRF   x62
.................... {  
....................    const float Curve_Value=0.041276;  
....................    float EXT_Minus_INT=0.00;  
....................    float TC_Voltage=0.00;  
....................    float INT_Temp=0.00;  
....................    float EXT_Temp=0.00;  
....................    int NIST_Index=0;  
....................  
....................      
....................    EXT_Temp=PreFilter();  
1456:  RCALL  10A4
1458:  MOVFF  03,61
145C:  MOVFF  02,60
1460:  MOVFF  01,5F
1464:  MOVFF  00,5E
....................    INT_Temp=readIntTemp();  
1468:  BRA    131C
146A:  MOVFF  03,5D
146E:  MOVFF  02,5C
1472:  MOVFF  01,5B
1476:  MOVFF  00,5A
....................  
....................    if(EXT_Temp<0.00)  
147A:  MOVFF  61,78
147E:  MOVFF  60,77
1482:  MOVFF  5F,76
1486:  MOVFF  5E,75
148A:  CLRF   x7C
148C:  CLRF   x7B
148E:  CLRF   x7A
1490:  CLRF   x79
1492:  RCALL  102E
1494:  BTFSS  FD8.0
1496:  BRA    1678
....................    {  
....................       EXT_Minus_INT=(EXT_Temp-INT_Temp);  
1498:  BSF    FD8.1
149A:  MOVFF  61,78
149E:  MOVFF  60,77
14A2:  MOVFF  5F,76
14A6:  MOVFF  5E,75
14AA:  MOVFF  5D,7C
14AE:  MOVFF  5C,7B
14B2:  MOVFF  5B,7A
14B6:  MOVFF  5A,79
14BA:  RCALL  0DC4
14BC:  MOVFF  03,55
14C0:  MOVFF  02,54
14C4:  MOVFF  01,53
14C8:  MOVFF  00,52
....................       TC_Voltage=EXT_Minus_INT*Curve_Value;  
14CC:  MOVFF  55,80
14D0:  MOVFF  54,7F
14D4:  MOVFF  53,7E
14D8:  MOVFF  52,7D
14DC:  MOVLW  06
14DE:  MOVWF  x84
14E0:  MOVLW  11
14E2:  MOVWF  x83
14E4:  MOVLW  29
14E6:  MOVWF  x82
14E8:  MOVLW  7A
14EA:  MOVWF  x81
14EC:  CALL   0BD4
14F0:  MOVFF  03,59
14F4:  MOVFF  02,58
14F8:  MOVFF  01,57
14FC:  MOVFF  00,56
.................... //fprintf(lcd_putc,"TC_Voltage:%3.2f\r\n",TC_Voltage);   //MATH OK  
....................  
.................... //fprintf(lcd_putc,"DEC_INT:%3.2f\r\n",INT_Temp);     
....................       while(NIST_Index<INT_Temp)NIST_Index++;  
1500:  CLRF   x7A
1502:  MOVFF  62,79
1506:  CALL   0994
150A:  MOVFF  03,78
150E:  MOVFF  02,77
1512:  MOVFF  01,76
1516:  MOVFF  00,75
151A:  MOVFF  5D,7C
151E:  MOVFF  5C,7B
1522:  MOVFF  5B,7A
1526:  MOVFF  5A,79
152A:  RCALL  102E
152C:  BNC   1532
152E:  INCF   x62,F
1530:  BRA    1500
....................       NIST_Index--;  
1532:  DECF   x62,F
....................  
.................... //fprintf(lcd_putc,"NIST:%d\r\n",NIST_Index);     
.................... //fprintf(lcd_putc,"NIST MV:%ld\r\n",PositiveK[NIST_Index]);     
....................       TC_Voltage+=(PositiveK[NIST_Index]/1000.00);  
1534:  CLRF   03
1536:  MOVFF  62,02
153A:  BCF    FD8.0
153C:  RLCF   02,F
153E:  RLCF   03,F
1540:  MOVF   02,W
1542:  MOVFF  FF2,63
1546:  BCF    FF2.7
1548:  MOVFF  03,FF7
154C:  CALL   01DA
1550:  TBLRD*+
1552:  MOVFF  FF5,03
1556:  BTFSC  x63.7
1558:  BSF    FF2.7
155A:  MOVWF  x63
155C:  MOVFF  03,64
1560:  MOVFF  03,7A
1564:  MOVWF  x79
1566:  CALL   0994
156A:  MOVFF  03,7C
156E:  MOVFF  02,7B
1572:  MOVFF  01,7A
1576:  MOVFF  00,79
157A:  CLRF   x80
157C:  CLRF   x7F
157E:  MOVLW  7A
1580:  MOVWF  x7E
1582:  MOVLW  88
1584:  MOVWF  x7D
1586:  CALL   0A7A
158A:  BCF    FD8.1
158C:  MOVFF  59,78
1590:  MOVFF  58,77
1594:  MOVFF  57,76
1598:  MOVFF  56,75
159C:  MOVFF  03,7C
15A0:  MOVFF  02,7B
15A4:  MOVFF  01,7A
15A8:  MOVFF  00,79
15AC:  RCALL  0DC4
15AE:  MOVFF  03,59
15B2:  MOVFF  02,58
15B6:  MOVFF  01,57
15BA:  MOVFF  00,56
....................       TC_Voltage*=-1000.00;     
15BE:  MOVFF  59,80
15C2:  MOVFF  58,7F
15C6:  MOVFF  57,7E
15CA:  MOVFF  56,7D
15CE:  CLRF   x84
15D0:  CLRF   x83
15D2:  MOVLW  FA
15D4:  MOVWF  x82
15D6:  MOVLW  88
15D8:  MOVWF  x81
15DA:  CALL   0BD4
15DE:  MOVFF  03,59
15E2:  MOVFF  02,58
15E6:  MOVFF  01,57
15EA:  MOVFF  00,56
.................... //fprintf(lcd_putc,"TC_Voltage2:%3.2f\r\n",TC_Voltage);  
....................      
....................       NIST_Index=0;  
15EE:  CLRF   x62
....................       while(TC_Voltage>NegativeK[NIST_Index])  
15F0:  CLRF   03
15F2:  MOVFF  62,02
15F6:  BCF    FD8.0
15F8:  RLCF   02,F
15FA:  RLCF   03,F
15FC:  MOVF   02,W
15FE:  MOVFF  FF2,63
1602:  BCF    FF2.7
1604:  MOVFF  03,FF7
1608:  CALL   0096
160C:  TBLRD*+
160E:  MOVFF  FF5,03
1612:  BTFSC  x63.7
1614:  BSF    FF2.7
1616:  MOVWF  x79
1618:  MOVFF  03,7A
161C:  CALL   0994
1620:  MOVFF  03,78
1624:  MOVFF  02,77
1628:  MOVFF  01,76
162C:  MOVFF  00,75
1630:  MOVFF  59,7C
1634:  MOVFF  58,7B
1638:  MOVFF  57,7A
163C:  MOVFF  56,79
1640:  RCALL  102E
1642:  BNC   1648
....................       {  
....................          NIST_Index++;  
1644:  INCF   x62,F
1646:  BRA    15F0
....................       }  
....................       NIST_Index--;  
1648:  DECF   x62,F
.................... //fprintf(lcd_putc,"EXT NIST:%d\r\n",NIST_Index);     
....................       return(NIST_Index*-1.00);  
164A:  CLRF   x7A
164C:  MOVFF  62,79
1650:  CALL   0994
1654:  MOVFF  03,80
1658:  MOVFF  02,7F
165C:  MOVFF  01,7E
1660:  MOVFF  00,7D
1664:  CLRF   x84
1666:  CLRF   x83
1668:  MOVLW  80
166A:  MOVWF  x82
166C:  MOVLW  7F
166E:  MOVWF  x81
1670:  CALL   0BD4
1674:  BRA    1688
....................    }  
1676:  BRA    1688
....................    else  
....................       return(EXT_Temp);  
1678:  MOVFF  5E,00
167C:  MOVFF  5F,01
1680:  MOVFF  60,02
1684:  MOVFF  61,03
1688:  GOTO   20D6 (RETURN)
.................... }  
....................  
.................... #include<stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <LCD_TM.c> 
.................... // Lcd 16x2 in 4 bit mode  
.................... // LCD.C file diver  
.................... // As defined in the following structure the pin connection is as follows: 
.................... // RB4 RS 
.................... // RB5 Enable 
.................... // RB0 DB4 
.................... // RB1 DB5 
.................... // RB2 DB6 
.................... // RB3 DB7 
.................... // 
.................... // LCD pins B0-B3 are not used and RW is not used. 
.................... #define rs PIN_C0      //B4 
.................... //rw connect gnd 
.................... #define enabled PIN_C1 //B5 
.................... #define DB4 PIN_A0 // B0 
.................... #define DB5 PIN_A1 // B1 
.................... #define DB6 PIN_A4 // B2 
.................... #define DB7 PIN_A5 // N3 
.................... char const lcd_type=2; 
.................... char const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
.................... //======================================= 
.................... //======================================= 
.................... void make_out_data(char buffer_data) 
.................... {  
.................... output_bit(DB4,bit_test(buffer_data,0)); 
*
04EA:  BTFSC  x68.0
04EC:  BRA    04F2
04EE:  BCF    F89.0
04F0:  BRA    04F4
04F2:  BSF    F89.0
04F4:  BCF    F92.0
.................... output_bit(DB5,bit_test(buffer_data,1)); 
04F6:  BTFSC  x68.1
04F8:  BRA    04FE
04FA:  BCF    F89.1
04FC:  BRA    0500
04FE:  BSF    F89.1
0500:  BCF    F92.1
.................... output_bit(DB6,bit_test(buffer_data,2)); 
0502:  BTFSC  x68.2
0504:  BRA    050A
0506:  BCF    F89.4
0508:  BRA    050C
050A:  BSF    F89.4
050C:  BCF    F92.4
.................... output_bit(DB7,bit_test(buffer_data,3)); 
050E:  BTFSC  x68.3
0510:  BRA    0516
0512:  BCF    F89.5
0514:  BRA    0518
0516:  BSF    F89.5
0518:  BCF    F92.5
051A:  GOTO   0524 (RETURN)
.................... } 
.................... //=================================== 
.................... //=================================== 
.................... void lcd_send_nibble(char buffer_nibble) 
.................... { make_out_data(buffer_nibble); 
051E:  MOVFF  67,68
0522:  BRA    04EA
.................... delay_us(10); 
0524:  MOVLW  10
0526:  MOVWF  00
0528:  DECFSZ 00,F
052A:  BRA    0528
052C:  NOP   
.................... output_high(enabled); 
052E:  BSF    F8B.1
.................... delay_us(10); 
0530:  MOVLW  10
0532:  MOVWF  00
0534:  DECFSZ 00,F
0536:  BRA    0534
0538:  NOP   
.................... output_low(enabled); 
053A:  BCF    F8B.1
053C:  RETURN 0
.................... } 
.................... //==================================== 
.................... //==================================== 
.................... void lcd_send_byte( char address, char n ) 
.................... { 
.................... output_low(rs); //rs= = 0; 
053E:  BCF    F8B.0
.................... delay_ms(1); 
0540:  MOVLW  01
0542:  MOVWF  x71
0544:  RCALL  04C4
.................... output_bit(rs,address);//lcd.rs = address; 
0546:  MOVF   x64,F
0548:  BNZ   054E
054A:  BCF    F8B.0
054C:  BRA    0550
054E:  BSF    F8B.0
.................... delay_us(20); 
0550:  MOVLW  20
0552:  MOVWF  00
0554:  DECFSZ 00,F
0556:  BRA    0554
0558:  BRA    055A
055A:  NOP   
.................... delay_us(20); 
055C:  MOVLW  20
055E:  MOVWF  00
0560:  DECFSZ 00,F
0562:  BRA    0560
0564:  BRA    0566
0566:  NOP   
.................... output_low(enabled);//lcd.enable = 0; 
0568:  BCF    F8B.1
.................... lcd_send_nibble(n >> 4); 
056A:  SWAPF  x65,W
056C:  MOVWF  x66
056E:  MOVLW  0F
0570:  ANDWF  x66,F
0572:  MOVFF  66,67
0576:  RCALL  051E
.................... lcd_send_nibble(n & 0xf); 
0578:  MOVF   x65,W
057A:  ANDLW  0F
057C:  MOVWF  x66
057E:  MOVWF  x67
0580:  RCALL  051E
0582:  RETURN 0
.................... } 
.................... //=============================================== 
.................... //=============================================== 
.................... void lcd_init() 
.................... { char i; 
.................... //set_tris_lcd(LCD_WRITE); 
.................... output_low(rs); //lcd.rs = 0; 
0584:  BCF    F8B.0
.................... //output_low(rw); //lcd.rw = 0; 
.................... output_low(enabled); //lcd.enable = 0; 
0586:  BCF    F8B.1
.................... delay_ms(200); 
0588:  MOVLW  C8
058A:  MOVWF  x71
058C:  RCALL  04C4
.................... for(i=1;i<=3;++i) 
058E:  MOVLW  01
0590:  MOVWF  52
0592:  MOVF   52,W
0594:  SUBLW  03
0596:  BNC   05A8
.................... { 
.................... lcd_send_nibble(3); 
0598:  MOVLW  03
059A:  MOVWF  x67
059C:  RCALL  051E
.................... delay_ms(10); 
059E:  MOVLW  0A
05A0:  MOVWF  x71
05A2:  RCALL  04C4
05A4:  INCF   52,F
05A6:  BRA    0592
.................... } 
.................... lcd_send_nibble(2); 
05A8:  MOVLW  02
05AA:  MOVWF  x67
05AC:  RCALL  051E
.................... for(i=0;i<=3;++i) 
05AE:  CLRF   52
05B0:  MOVF   52,W
05B2:  SUBLW  03
05B4:  BNC   05D2
.................... lcd_send_byte(0,LCD_INIT_STRING[i]); 
05B6:  CLRF   03
05B8:  MOVF   52,W
05BA:  MOVFF  FF2,53
05BE:  BCF    FF2.7
05C0:  RCALL  031E
05C2:  BTFSC  53.7
05C4:  BSF    FF2.7
05C6:  MOVWF  53
05C8:  CLRF   x64
05CA:  MOVWF  x65
05CC:  RCALL  053E
05CE:  INCF   52,F
05D0:  BRA    05B0
05D2:  RETURN 0
.................... } 
.................... //================================================ 
.................... //================================================ 
.................... void lcd_gotoxy( char x, char y) 
.................... {char address; 
.................... switch(y) { 
*
18DA:  MOVLW  01
18DC:  SUBWF  x61,W
18DE:  ADDLW  FC
18E0:  BC    18FE
18E2:  ADDLW  04
18E4:  GOTO   1914
.................... case 1 : address=0x80;break; 
18E8:  MOVLW  80
18EA:  MOVWF  x62
18EC:  BRA    18FE
.................... case 2 : address=0xc0;break; 
18EE:  MOVLW  C0
18F0:  MOVWF  x62
18F2:  BRA    18FE
.................... case 3 : address=0x94;break; 
18F4:  MOVLW  94
18F6:  MOVWF  x62
18F8:  BRA    18FE
.................... case 4 : address=0xd4;break; 
18FA:  MOVLW  D4
18FC:  MOVWF  x62
.................... } 
.................... address=address+(x-1); 
18FE:  MOVLW  01
1900:  SUBWF  x60,W
1902:  ADDWF  x62,F
.................... lcd_send_byte(0,0x80|address); 
1904:  MOVF   x62,W
1906:  IORLW  80
1908:  MOVWF  x63
190A:  CLRF   x64
190C:  MOVWF  x65
190E:  CALL   053E
1912:  RETURN 0
.................... } 
.................... //================================================= 
.................... //================================================= 
.................... void lcd_putc( char c) { 
.................... switch (c) { 
*
1940:  MOVF   5F,W
1942:  XORLW  0C
1944:  BZ    1950
1946:  XORLW  06
1948:  BZ    1964
194A:  XORLW  02
194C:  BZ    1970
194E:  BRA    197C
.................... case '\f' : lcd_send_byte(0,1); 
1950:  CLRF   x64
1952:  MOVLW  01
1954:  MOVWF  x65
1956:  CALL   053E
.................... delay_ms(2); break; 
195A:  MOVLW  02
195C:  MOVWF  x71
195E:  CALL   04C4
1962:  BRA    1988
.................... case '\n' : lcd_gotoxy(1,2); break; 
1964:  MOVLW  01
1966:  MOVWF  x60
1968:  MOVLW  02
196A:  MOVWF  x61
196C:  RCALL  18DA
196E:  BRA    1988
.................... case '\b' : lcd_send_byte(0,0x10); break; 
1970:  CLRF   x64
1972:  MOVLW  10
1974:  MOVWF  x65
1976:  CALL   053E
197A:  BRA    1988
.................... default : lcd_send_byte(1,c); break; 
197C:  MOVLW  01
197E:  MOVWF  x64
1980:  MOVFF  5F,65
1984:  CALL   053E
.................... } 
1988:  RETURN 0
.................... } 
.................... //==================================================== 
.................... void LCD_Command(int cm); 
.................... void LCD_ShiftLeft(void); 
.................... void LCD_ShiftRight(void); 
.................... void LCD_MoveRight(char p); 
.................... void LCD_MoveLeft(char p); 
.................... void LCD_String(char*s,int dly); 
....................  
.................... void LCD_Command(int cm){ 
.................... lcd_send_byte(0,cm); 
.................... } 
....................  
.................... void LCD_ShiftLeft(void){ 
.................... lcd_send_byte(0,0x18); 
.................... } 
.................... void LCD_ShiftRight(void){ 
.................... lcd_send_byte(0,0x1C); 
.................... } 
.................... void LCD_MoveRight(char p){ 
.................... char i; 
.................... for(i=0;i<p;i++){ 
.................... LCD_ShiftRight(); 
.................... delay_ms(100); 
.................... } 
.................... } 
.................... void LCD_MoveLeft(char p){ 
.................... char i; 
.................... for(i=0;i<p;i++){ 
.................... LCD_ShiftLeft(); 
.................... delay_ms(100); 
.................... } 
.................... } 
.................... /* 
.................... void strcpy(char*s1,char*s2) { 
.................... while(*s1++ == *s2++); 
.................... } 
.................... */ 
.................... void LCD_String(char*s, int dly) { 
.................... while(*s!=0) { 
.................... lcd_putc(*s++); 
.................... delay_ms(dly); 
.................... } 
.................... } 
....................  
.................... int16 ms; 
....................  
.................... #int_timer1 
.................... void isr_timer2(void) { 
....................    ms++; //keep a running timer that increments every milli-second 
*
033C:  INCF   20,F
033E:  BTFSC  FD8.2
0340:  INCF   21,F
0342:  BCF    F9E.0
0344:  GOTO   0054
.................... } 
....................  
.................... void main() { 
*
1E7E:  CLRF   FF8
1E80:  BCF    FD0.7
1E82:  BSF    07.7
1E84:  BSF    FB8.3
1E86:  MOVLW  81
1E88:  MOVWF  FAF
1E8A:  MOVLW  00
1E8C:  MOVWF  FB0
1E8E:  MOVLW  A6
1E90:  MOVWF  FAC
1E92:  MOVLW  90
1E94:  MOVWF  FAB
1E96:  BSF    F93.4
1E98:  BCF    F93.5
1E9A:  BCF    F8A.5
1E9C:  MOVF   FC1,W
1E9E:  ANDLW  C0
1EA0:  IORLW  0F
1EA2:  MOVWF  FC1
1EA4:  CLRF   16
1EA6:  CLRF   17
1EA8:  CLRF   18
1EAA:  CLRF   19
1EAC:  CLRF   1A
1EAE:  CLRF   1B
1EB0:  CLRF   3B
1EB2:  CLRF   3A
1EB4:  CLRF   39
1EB6:  MOVLW  1D
1EB8:  MOVWF  38
1EBA:  BCF    3C.0
1EBC:  BSF    3C.1
1EBE:  MOVLW  08
1EC0:  MOVWF  3D
1EC2:  MOVLW  03
1EC4:  MOVWF  3E
....................    //setup_spi(SPI_MASTER | SPI_MODE_1 | SPI_CLK_DIV_64, );  
....................    struct rx_stat rxstat; 
....................    int32 rx_id; 
....................    int in_data[8]; 
....................    int rx_len; 
....................  
.................... //send a request (tx_rtr=1) for 8 bytes of data (tx_len=8) from id 24 (tx_id=24) 
....................    int out_data[8]; 
....................    int32 tx_id=29; // id = 0x29 for MAX31855 temperature 
....................     
....................    int1 tx_rtr=0;// CU LA 1 
....................    int1 tx_ext=1;// CU LA 0 
....................    int tx_len=8; 
....................    int tx_pri=3; 
....................  
....................    int i; 
....................    
....................     
....................    for (i=0;i<8;i++) { 
1EC6:  CLRF   3F
1EC8:  MOVF   3F,W
1ECA:  SUBLW  07
1ECC:  BNC   1EF4
....................       out_data[i]=0x33; 
1ECE:  CLRF   03
1ED0:  MOVF   3F,W
1ED2:  ADDLW  30
1ED4:  MOVWF  FE9
1ED6:  MOVLW  00
1ED8:  ADDWFC 03,W
1EDA:  MOVWF  FEA
1EDC:  MOVLW  33
1EDE:  MOVWF  FEF
....................       in_data[i]=0; 
1EE0:  CLRF   03
1EE2:  MOVF   3F,W
1EE4:  ADDLW  27
1EE6:  MOVWF  FE9
1EE8:  MOVLW  00
1EEA:  ADDWFC 03,W
1EEC:  MOVWF  FEA
1EEE:  CLRF   FEF
1EF0:  INCF   3F,F
1EF2:  BRA    1EC8
....................     
....................       
....................    } 
....................  
....................  //////////////////// 
.................... union conv {  
....................     float f;  
....................     int8 b[4];  
....................   }; 
....................   union conv Max31855exthermo;  // p is alias pointer 
.................... //val1.f=123.45;  
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",tempp.f,\  
.................... //    val1.b[0],val1.b[1],val1.b[2],val1.b[3]);  
....................     //The four bytes that make up the float  
....................  
.................... //Put four bytes into the second  
.................... /* 
.................... val2.b[0]= 0x86;  
.................... val2.b[1]= 0x6A;  
.................... val2.b[2]= 0x8F;  
.................... val2.b[3]= 0x5C;  
.................... */ 
.................... /* 
.................... out_data[0] = Max31855exthermo.b[0]; 
.................... out_data[1] = Max31855exthermo.b[1]; 
.................... out_data[2] = Max31855exthermo.b[2]; 
.................... out_data[3] = Max31855exthermo.b[3]; 
....................  
.................... */ 
.................... //printf(" %4.4f : %x : %x : %x : %x \r\n",val2.f,\  
.................... //    val2.b[0],val2.b[1],val2.b[2],val2.b[3]);  
.................... //    //The new float value, and the bytes that make it.  
....................  
....................  ////////////////////  
....................  float thermo, exthermo, inthermo; 
....................  int8 low, high; 
....................    printf("\r\n\r\nCCS CAN TRANSFER BME280 DATA\r\n"); 
1EF4:  MOVLW  48
1EF6:  MOVWF  FF6
1EF8:  MOVLW  03
1EFA:  MOVWF  FF7
1EFC:  CALL   04A2
....................  
....................    //setup_timer_2(T2_DIV_BY_4,79,16);   //setup up timer2 to interrupt every 1ms if using 20Mhz clock 
....................     
....................    // init lcd 
....................    lcd_init(); 
1F00:  CALL   0584
....................   // lcd_gotoxy(1,1); 
....................   // printf(lcd_putc,"BSD PROJECT");   
....................    lcd_init(); 
1F04:  CALL   0584
....................     
....................    can_init(); 
1F08:  GOTO   0756
....................   
....................     
....................   // can_set_mode(CAN_OP_LOOPBACK); 
....................    setup_timer_2(T2_DIV_BY_16, 24, 1);   // 
1F0C:  MOVLW  00
1F0E:  IORLW  06
1F10:  MOVWF  FCA
1F12:  MOVLW  18
1F14:  MOVWF  FCB
....................    enable_interrupts(INT_TIMER1);   //enable timer2 interrupt 
1F16:  BSF    F9D.0
....................    set_tris_c(0x00); 
1F18:  MOVLW  00
1F1A:  MOVWF  F94
....................    output_low(PIN_C2); 
1F1C:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
1F1E:  BCF    F8B.2
1F20:  MOVLW  0C
1F22:  MOVWF  FBD
....................    enable_interrupts(GLOBAL);       //enable all interrupts (else timer2 wont happen) 
1F24:  MOVLW  C0
1F26:  IORWF  FF2,F
....................    setup_adc(ADC_CLOCK_INTERNAL); //ADC_CLOCK_DIV_8 
1F28:  MOVF   FC0,W
1F2A:  ANDLW  C0
1F2C:  IORLW  07
1F2E:  MOVWF  FC0
1F30:  BCF    FC0.7
1F32:  BSF    FC2.0
....................    setup_adc_ports(AN0_TO_AN1); //ALL_ANALOG 
1F34:  MOVF   FC1,W
1F36:  ANDLW  C0
1F38:  IORLW  0D
1F3A:  MOVWF  FC1
....................    //#define VSS_VDD 
....................    printf("\r\nRunning..."); 
1F3C:  MOVLW  6C
1F3E:  MOVWF  FF6
1F40:  MOVLW  03
1F42:  MOVWF  FF7
1F44:  CALL   04A2
....................     
....................    // quat cu 
....................    while(TRUE) 
....................    {    
....................          
....................        set_adc_channel(0); // EasyPIC Board: Read ADC 2 for PWM fan 
1F48:  MOVLW  00
1F4A:  MOVWF  01
1F4C:  MOVF   FC2,W
1F4E:  ANDLW  C3
1F50:  IORWF  01,W
1F52:  MOVWF  FC2
....................        delay_ms(20); 
1F54:  MOVLW  14
1F56:  MOVWF  x71
1F58:  CALL   04C4
....................        low= read_adc()/7; // 36 
1F5C:  BSF    FC2.1
1F5E:  BTFSC  FC2.1
1F60:  BRA    1F5E
1F62:  MOVFF  FC4,58
1F66:  MOVLW  07
1F68:  MOVWF  59
1F6A:  CALL   0832
1F6E:  MOVFF  01,50
....................        if(low <30) 
1F72:  MOVF   50,W
1F74:  SUBLW  1D
1F76:  BNC   1F7C
....................        low =30; 
1F78:  MOVLW  1E
1F7A:  MOVWF  50
....................        printf("\r\n\low=%u",low); 
1F7C:  MOVLW  7A
1F7E:  MOVWF  FF6
1F80:  MOVLW  03
1F82:  MOVWF  FF7
1F84:  MOVLW  06
1F86:  MOVWF  56
1F88:  CALL   085A
1F8C:  MOVFF  50,56
1F90:  MOVLW  1B
1F92:  MOVWF  57
1F94:  CALL   087A
....................        set_adc_channel(1); // EasyPIC Board: Read ADC 2 for PWM fan 
1F98:  MOVLW  04
1F9A:  MOVWF  01
1F9C:  MOVF   FC2,W
1F9E:  ANDLW  C3
1FA0:  IORWF  01,W
1FA2:  MOVWF  FC2
....................        delay_ms(20); 
1FA4:  MOVLW  14
1FA6:  MOVWF  x71
1FA8:  CALL   04C4
....................        high= read_adc()/5; //63 
1FAC:  BSF    FC2.1
1FAE:  BTFSC  FC2.1
1FB0:  BRA    1FAE
1FB2:  MOVFF  FC4,58
1FB6:  MOVLW  05
1FB8:  MOVWF  59
1FBA:  CALL   0832
1FBE:  MOVFF  01,51
....................        if(high < 40) 
1FC2:  MOVF   51,W
1FC4:  SUBLW  27
1FC6:  BNC   1FCC
....................        high = 40; 
1FC8:  MOVLW  28
1FCA:  MOVWF  51
....................        if(high>50) 
1FCC:  MOVF   51,W
1FCE:  SUBLW  32
1FD0:  BC    1FD6
....................        high = 50; 
1FD2:  MOVLW  32
1FD4:  MOVWF  51
....................        //high = high + 35; 
....................        //if((high > 60)||(high<35)) 
....................        //high = 60; 
....................        printf("\r\n\high=%u",high); 
1FD6:  MOVLW  84
1FD8:  MOVWF  FF6
1FDA:  MOVLW  03
1FDC:  MOVWF  FF7
1FDE:  MOVLW  07
1FE0:  MOVWF  56
1FE2:  CALL   085A
1FE6:  MOVFF  51,56
1FEA:  MOVLW  1B
1FEC:  MOVWF  57
1FEE:  CALL   087A
....................         
....................        thermo = readMAX(); 
1FF2:  CALL   0922
1FF6:  CLRF   x7A
1FF8:  CLRF   x79
1FFA:  CALL   0994
1FFE:  MOVFF  03,47
2002:  MOVFF  02,46
2006:  MOVFF  01,45
200A:  MOVFF  00,44
....................        delay_ms(20); 
200E:  MOVLW  14
2010:  MOVWF  x71
2012:  CALL   04C4
....................         
....................        printf("\r\nSPIVAL3 = %X SPIVAL2 = %X SPIVAL1 = %X SPIVAL0 = %X ", spival[3], spival[2], spival[1], spival[0]); 
2016:  MOVLW  8E
2018:  MOVWF  FF6
201A:  MOVLW  03
201C:  MOVWF  FF7
201E:  MOVLW  0C
2020:  MOVWF  56
2022:  CALL   085A
2026:  MOVFF  19,53
202A:  MOVLW  37
202C:  MOVWF  54
202E:  CALL   09CA
2032:  MOVLW  9C
2034:  MOVWF  FF6
2036:  MOVLW  03
2038:  MOVWF  FF7
203A:  MOVLW  0B
203C:  MOVWF  56
203E:  CALL   085A
2042:  MOVFF  18,53
2046:  MOVLW  37
2048:  MOVWF  54
204A:  CALL   09CA
204E:  MOVLW  A9
2050:  MOVWF  FF6
2052:  MOVLW  03
2054:  MOVWF  FF7
2056:  MOVLW  0B
2058:  MOVWF  56
205A:  CALL   085A
205E:  MOVFF  17,53
2062:  MOVLW  37
2064:  MOVWF  54
2066:  CALL   09CA
206A:  MOVLW  B6
206C:  MOVWF  FF6
206E:  MOVLW  03
2070:  MOVWF  FF7
2072:  MOVLW  0B
2074:  MOVWF  56
2076:  CALL   085A
207A:  MOVFF  16,53
207E:  MOVLW  37
2080:  MOVWF  54
2082:  CALL   09CA
2086:  MOVLW  20
2088:  BTFSS  F9E.4
208A:  BRA    2088
208C:  MOVWF  FAD
....................         //thermo1 = readExtTemp(); 
....................        delay_ms(10); 
208E:  MOVLW  0A
2090:  MOVWF  x71
2092:  CALL   04C4
....................        // printf("\r\nThermocouple 1 = %f", thermo1); 
....................        exthermo = PreFilter() ; 
2096:  CALL   10A4
209A:  MOVFF  03,4B
209E:  MOVFF  02,4A
20A2:  MOVFF  01,49
20A6:  MOVFF  00,48
....................        delay_ms(10); 
20AA:  MOVLW  0A
20AC:  MOVWF  x71
20AE:  CALL   04C4
....................        Max31855exthermo.f = exthermo; 
20B2:  MOVFF  4B,43
20B6:  MOVFF  4A,42
20BA:  MOVFF  49,41
20BE:  MOVFF  48,40
....................         
....................        out_data[0] = Max31855exthermo.b[0]; 
20C2:  MOVFF  40,30
....................        out_data[1] = Max31855exthermo.b[1]; 
20C6:  MOVFF  41,31
....................        out_data[2] = Max31855exthermo.b[2]; 
20CA:  MOVFF  42,32
....................        out_data[3] = Max31855exthermo.b[3]; 
20CE:  MOVFF  43,33
....................         
....................        inthermo = Linearized_TC(); 
20D2:  GOTO   1434
20D6:  MOVFF  03,4F
20DA:  MOVFF  02,4E
20DE:  MOVFF  01,4D
20E2:  MOVFF  00,4C
....................        delay_ms(10); 
20E6:  MOVLW  0A
20E8:  MOVWF  x71
20EA:  CALL   04C4
....................        printf("\r\Pre Filter = %f Linearized = %f ", exthermo, inthermo); 
20EE:  MOVLW  C6
20F0:  MOVWF  FF6
20F2:  MOVLW  03
20F4:  MOVWF  FF7
20F6:  MOVLW  0E
20F8:  MOVWF  56
20FA:  CALL   085A
20FE:  MOVLW  89
2100:  MOVWF  FE9
2102:  MOVFF  4B,55
2106:  MOVFF  4A,54
210A:  MOVFF  49,53
210E:  MOVFF  48,52
2112:  MOVLW  02
2114:  MOVWF  56
2116:  CALL   1758
211A:  MOVLW  D6
211C:  MOVWF  FF6
211E:  MOVLW  03
2120:  MOVWF  FF7
2122:  MOVLW  0E
2124:  MOVWF  56
2126:  CALL   085A
212A:  MOVLW  89
212C:  MOVWF  FE9
212E:  MOVFF  4F,55
2132:  MOVFF  4E,54
2136:  MOVFF  4D,53
213A:  MOVFF  4C,52
213E:  MOVLW  02
2140:  MOVWF  56
2142:  CALL   1758
2146:  MOVLW  20
2148:  BTFSS  F9E.4
214A:  BRA    2148
214C:  MOVWF  FAD
....................          
....................         lcd_gotoxy(1,1); 
214E:  MOVLW  01
2150:  MOVWF  x60
2152:  MOVWF  x61
2154:  CALL   18DA
....................         printf(lcd_putc,"T=%3.1f",exthermo); 
2158:  MOVLW  54
215A:  MOVWF  5F
215C:  CALL   1940
2160:  MOVLW  3D
2162:  MOVWF  5F
2164:  CALL   1940
2168:  MOVLW  02
216A:  MOVWF  FE9
216C:  MOVFF  4B,55
2170:  MOVFF  4A,54
2174:  MOVFF  49,53
2178:  MOVFF  48,52
217C:  MOVLW  01
217E:  MOVWF  56
2180:  BRA    198A
....................        lcd_gotoxy(1,2); 
2182:  MOVLW  01
2184:  MOVWF  x60
2186:  MOVLW  02
2188:  MOVWF  x61
218A:  CALL   18DA
....................        printf(lcd_putc,"ID:0x29"); 
218E:  MOVLW  E8
2190:  MOVWF  FF6
2192:  MOVLW  03
2194:  MOVWF  FF7
2196:  BRA    1B06
....................        set_pwm1_duty(high);  
2198:  MOVFF  51,FBE
....................         
....................        
....................        if(exthermo > high) 
219C:  CLRF   x7A
219E:  MOVFF  51,79
21A2:  CALL   0994
21A6:  MOVFF  03,78
21AA:  MOVFF  02,77
21AE:  MOVFF  01,76
21B2:  MOVFF  00,75
21B6:  MOVFF  4B,7C
21BA:  MOVFF  4A,7B
21BE:  MOVFF  49,7A
21C2:  MOVFF  48,79
21C6:  CALL   102E
21CA:  BNC   21CE
....................        { 
....................        set_pwm1_duty(255);  
21CC:  SETF   FBE
....................        } 
....................        if((exthermo  < low)) 
21CE:  CLRF   x7A
21D0:  MOVFF  50,79
21D4:  CALL   0994
21D8:  MOVFF  4B,78
21DC:  MOVFF  4A,77
21E0:  MOVFF  49,76
21E4:  MOVFF  48,75
21E8:  MOVFF  03,7C
21EC:  MOVFF  02,7B
21F0:  MOVFF  01,7A
21F4:  MOVFF  00,79
21F8:  CALL   102E
21FC:  BNC   2202
....................        { 
....................        set_pwm1_duty(8);  
21FE:  MOVLW  08
2200:  MOVWF  FBE
....................        } 
....................        if((exthermo > low)&&(exthermo < high)) 
2202:  CLRF   x7A
2204:  MOVFF  50,79
2208:  CALL   0994
220C:  MOVFF  03,78
2210:  MOVFF  02,77
2214:  MOVFF  01,76
2218:  MOVFF  00,75
221C:  MOVFF  4B,7C
2220:  MOVFF  4A,7B
2224:  MOVFF  49,7A
2228:  MOVFF  48,79
222C:  CALL   102E
2230:  BNC   2266
2232:  CLRF   x7A
2234:  MOVFF  51,79
2238:  CALL   0994
223C:  MOVFF  4B,78
2240:  MOVFF  4A,77
2244:  MOVFF  49,76
2248:  MOVFF  48,75
224C:  MOVFF  03,7C
2250:  MOVFF  02,7B
2254:  MOVFF  01,7A
2258:  MOVFF  00,79
225C:  CALL   102E
2260:  BNC   2266
....................        { 
....................        set_pwm1_duty(18);  
2262:  MOVLW  12
2264:  MOVWF  FBE
....................        } 
....................        // lcd_gotoxy(1,2); 
....................        // printf(lcd_putc,"T=%3.1f",inthermo); 
....................          
....................       if ( can_kbhit() )   //if data is waiting in buffer... 
2266:  BTFSC  F60.7
2268:  BRA    2272
226A:  MOVLB  F
226C:  BTFSS  x50.7
226E:  BRA    2502
2270:  MOVLB  0
....................       { 
....................          if(can_getd(rx_id, &in_data[0], rx_len, rxstat)) { //...then get data from buffer 
2272:  CLRF   53
2274:  MOVLW  27
2276:  MOVWF  52
*
2374:  MOVF   01,F
2376:  BTFSC  FD8.2
2378:  BRA    24F2
....................             printf("\r\nGOT: BUFF=%U ID=%LU LEN=%U OVF=%U ", rxstat.buffer, rx_id, rx_len, rxstat.err_ovfl); 
237A:  MOVLW  00
237C:  BTFSC  22.4
237E:  MOVLW  01
2380:  MOVWF  52
2382:  MOVLW  00
2384:  BTFSC  22.0
2386:  MOVLW  01
2388:  MOVWF  53
238A:  MOVLW  F0
238C:  MOVWF  FF6
238E:  MOVLW  03
2390:  MOVWF  FF7
2392:  MOVLW  0C
2394:  MOVWF  56
2396:  MOVLB  0
2398:  CALL   085A
239C:  MOVFF  52,56
23A0:  MOVLW  1B
23A2:  MOVWF  57
23A4:  CALL   087A
23A8:  MOVLW  FE
23AA:  MOVWF  FF6
23AC:  MOVLW  03
23AE:  MOVWF  FF7
23B0:  MOVLW  04
23B2:  MOVWF  56
23B4:  CALL   085A
23B8:  MOVLW  41
23BA:  MOVWF  FE9
23BC:  MOVFF  26,57
23C0:  MOVFF  25,56
23C4:  MOVFF  24,55
23C8:  MOVFF  23,54
23CC:  RCALL  1D0A
23CE:  MOVLW  05
23D0:  MOVWF  FF6
23D2:  MOVLW  04
23D4:  MOVWF  FF7
23D6:  MOVLW  05
23D8:  MOVWF  56
23DA:  CALL   085A
23DE:  MOVFF  2F,56
23E2:  MOVLW  1B
23E4:  MOVWF  57
23E6:  CALL   087A
23EA:  MOVLW  0C
23EC:  MOVWF  FF6
23EE:  MOVLW  04
23F0:  MOVWF  FF7
23F2:  MOVLW  05
23F4:  MOVWF  56
23F6:  CALL   085A
23FA:  MOVFF  53,56
23FE:  MOVLW  1B
2400:  MOVWF  57
2402:  CALL   087A
2406:  MOVLW  20
2408:  BTFSS  F9E.4
240A:  BRA    2408
240C:  MOVWF  FAD
....................             printf("FILT=%U RTR=%U EXT=%U INV=%U", rxstat.filthit, rxstat.rtr, rxstat.ext, rxstat.inv); 
240E:  MOVFF  22,00
2412:  RRCF   22,W
2414:  ANDLW  07
2416:  MOVWF  52
2418:  MOVLW  00
241A:  BTFSC  22.5
241C:  MOVLW  01
241E:  MOVWF  53
2420:  MOVLW  00
2422:  BTFSC  22.6
2424:  MOVLW  01
2426:  MOVWF  54
2428:  MOVLW  00
242A:  BTFSC  22.7
242C:  MOVLW  01
242E:  MOVWF  55
2430:  MOVLW  16
2432:  MOVWF  FF6
2434:  MOVLW  04
2436:  MOVWF  FF7
2438:  MOVLW  05
243A:  MOVWF  56
243C:  CALL   085A
2440:  MOVFF  52,56
2444:  MOVLW  1B
2446:  MOVWF  57
2448:  CALL   087A
244C:  MOVLW  1D
244E:  MOVWF  FF6
2450:  MOVLW  04
2452:  MOVWF  FF7
2454:  MOVLW  05
2456:  MOVWF  56
2458:  CALL   085A
245C:  MOVFF  53,56
2460:  MOVLW  1B
2462:  MOVWF  57
2464:  CALL   087A
2468:  MOVLW  24
246A:  MOVWF  FF6
246C:  MOVLW  04
246E:  MOVWF  FF7
2470:  MOVLW  05
2472:  MOVWF  56
2474:  CALL   085A
2478:  MOVFF  54,56
247C:  MOVLW  1B
247E:  MOVWF  57
2480:  CALL   087A
2484:  MOVLW  2B
2486:  MOVWF  FF6
2488:  MOVLW  04
248A:  MOVWF  FF7
248C:  MOVLW  05
248E:  MOVWF  56
2490:  CALL   085A
2494:  MOVFF  55,56
2498:  MOVLW  1B
249A:  MOVWF  57
249C:  CALL   087A
....................             printf("\r\n    DATA = "); 
24A0:  MOVLW  34
24A2:  MOVWF  FF6
24A4:  MOVLW  04
24A6:  MOVWF  FF7
24A8:  CALL   04A2
....................             for (i=0;i<rx_len;i++) { 
24AC:  CLRF   3F
24AE:  MOVF   2F,W
24B0:  SUBWF  3F,W
24B2:  BC    24DE
....................                printf("%X ",in_data[i]); 
24B4:  CLRF   03
24B6:  MOVF   3F,W
24B8:  ADDLW  27
24BA:  MOVWF  FE9
24BC:  MOVLW  00
24BE:  ADDWFC 03,W
24C0:  MOVWF  FEA
24C2:  MOVFF  FEF,52
24C6:  MOVFF  52,53
24CA:  MOVLW  37
24CC:  MOVWF  54
24CE:  CALL   09CA
24D2:  MOVLW  20
24D4:  BTFSS  F9E.4
24D6:  BRA    24D4
24D8:  MOVWF  FAD
24DA:  INCF   3F,F
24DC:  BRA    24AE
....................             } 
....................             printf("\r\n"); 
24DE:  MOVLW  0D
24E0:  BTFSS  F9E.4
24E2:  BRA    24E0
24E4:  MOVWF  FAD
24E6:  MOVLW  0A
24E8:  BTFSS  F9E.4
24EA:  BRA    24E8
24EC:  MOVWF  FAD
....................          } 
24EE:  BRA    2500
24F0:  MOVLB  F
....................          else { 
....................             printf("\r\nFAIL on GETD\r\n"); 
24F2:  MOVLW  42
24F4:  MOVWF  FF6
24F6:  MOVLW  04
24F8:  MOVWF  FF7
24FA:  MOVLB  0
24FC:  CALL   04A2
2500:  MOVLB  F
....................          } 
....................  
....................       } 
....................       //every two seconds, send new data if transmit buffer is empty 
....................       if ( can_tbe() && (ms > 2000)) 
2502:  BTFSS  x40.3
2504:  BRA    250E
2506:  BTFSS  x30.3
2508:  BRA    250E
250A:  BTFSC  x20.3
250C:  BRA    26A8
250E:  MOVF   21,W
2510:  SUBLW  06
2512:  BTFSC  FD8.0
2514:  BRA    26A8
2516:  XORLW  FF
2518:  BNZ   2522
251A:  MOVF   20,W
251C:  SUBLW  D0
251E:  BTFSC  FD8.0
2520:  BRA    26A8
....................       { 
....................          ms=0; 
2522:  CLRF   21
2524:  CLRF   20
....................          i=can_putd(tx_id, out_data, tx_len,tx_pri,tx_ext,tx_rtr); //put data on transmit buffer 
2526:  MOVLW  00
2528:  BTFSC  3C.1
252A:  MOVLW  01
252C:  MOVWF  52
252E:  MOVLW  00
2530:  BTFSC  3C.0
2532:  MOVLW  01
2534:  MOVWF  53
2536:  MOVFF  3B,57
253A:  MOVFF  3A,56
253E:  MOVFF  39,55
2542:  MOVFF  38,54
2546:  CLRF   59
2548:  MOVLW  30
254A:  MOVWF  58
254C:  MOVFF  3D,5A
2550:  MOVFF  3E,5B
2554:  MOVFF  52,5C
2558:  MOVFF  53,5D
255C:  MOVLB  0
255E:  BRA    1DB0
2560:  MOVFF  01,3F
....................          if (i != 0xFF) { //success, a transmit buffer was open 
2564:  INCFSZ 3F,W
2566:  BRA    256A
2568:  BRA    269A
....................             printf("\r\nPUT %U: ID=%LU LEN=%U ", i, tx_id, tx_len);  //i return 1 if transmit success 
256A:  MOVLW  54
256C:  MOVWF  FF6
256E:  MOVLW  04
2570:  MOVWF  FF7
2572:  MOVLW  06
2574:  MOVWF  56
2576:  CALL   085A
257A:  MOVFF  3F,56
257E:  MOVLW  1B
2580:  MOVWF  57
2582:  CALL   087A
2586:  MOVLW  5C
2588:  MOVWF  FF6
258A:  MOVLW  04
258C:  MOVWF  FF7
258E:  MOVLW  05
2590:  MOVWF  56
2592:  CALL   085A
2596:  MOVLW  41
2598:  MOVWF  FE9
259A:  MOVFF  3B,57
259E:  MOVFF  3A,56
25A2:  MOVFF  39,55
25A6:  MOVFF  38,54
25AA:  CALL   1D0A
25AE:  MOVLW  64
25B0:  MOVWF  FF6
25B2:  MOVLW  04
25B4:  MOVWF  FF7
25B6:  MOVLW  05
25B8:  MOVWF  56
25BA:  CALL   085A
25BE:  MOVFF  3D,56
25C2:  MOVLW  1B
25C4:  MOVWF  57
25C6:  CALL   087A
25CA:  MOVLW  20
25CC:  BTFSS  F9E.4
25CE:  BRA    25CC
25D0:  MOVWF  FAD
....................             printf("PRI=%U EXT=%U RTR=%U\r\n   DATA = ", tx_pri, tx_ext, tx_rtr); 
25D2:  MOVLW  00
25D4:  BTFSC  3C.1
25D6:  MOVLW  01
25D8:  MOVWF  52
25DA:  MOVLW  00
25DC:  BTFSC  3C.0
25DE:  MOVLW  01
25E0:  MOVWF  53
25E2:  MOVLW  6E
25E4:  MOVWF  FF6
25E6:  MOVLW  04
25E8:  MOVWF  FF7
25EA:  MOVLW  04
25EC:  MOVWF  56
25EE:  CALL   085A
25F2:  MOVFF  3E,56
25F6:  MOVLW  1B
25F8:  MOVWF  57
25FA:  CALL   087A
25FE:  MOVLW  74
2600:  MOVWF  FF6
2602:  MOVLW  04
2604:  MOVWF  FF7
2606:  MOVLW  05
2608:  MOVWF  56
260A:  CALL   085A
260E:  MOVFF  52,56
2612:  MOVLW  1B
2614:  MOVWF  57
2616:  CALL   087A
261A:  MOVLW  7B
261C:  MOVWF  FF6
261E:  MOVLW  04
2620:  MOVWF  FF7
2622:  MOVLW  05
2624:  MOVWF  56
2626:  CALL   085A
262A:  MOVFF  53,56
262E:  MOVLW  1B
2630:  MOVWF  57
2632:  CALL   087A
2636:  MOVLW  82
2638:  MOVWF  FF6
263A:  MOVLW  04
263C:  MOVWF  FF7
263E:  MOVLW  0C
2640:  MOVWF  56
2642:  CALL   085A
....................             //  printf("\r\nID=%X", out_data[0]); 
....................             for (i=0;i<tx_len;i++) { 
2646:  CLRF   3F
2648:  MOVF   3D,W
264A:  SUBWF  3F,W
264C:  BC    2688
....................                printf("\r\n%X ",out_data[i]); 
264E:  CLRF   03
2650:  MOVF   3F,W
2652:  ADDLW  30
2654:  MOVWF  FE9
2656:  MOVLW  00
2658:  ADDWFC 03,W
265A:  MOVWF  FEA
265C:  MOVFF  FEF,52
2660:  MOVLW  0D
2662:  BTFSS  F9E.4
2664:  BRA    2662
2666:  MOVWF  FAD
2668:  MOVLW  0A
266A:  BTFSS  F9E.4
266C:  BRA    266A
266E:  MOVWF  FAD
2670:  MOVFF  52,53
2674:  MOVLW  37
2676:  MOVWF  54
2678:  CALL   09CA
267C:  MOVLW  20
267E:  BTFSS  F9E.4
2680:  BRA    267E
2682:  MOVWF  FAD
2684:  INCF   3F,F
2686:  BRA    2648
....................             } 
....................             printf("\r\n"); 
2688:  MOVLW  0D
268A:  BTFSS  F9E.4
268C:  BRA    268A
268E:  MOVWF  FAD
2690:  MOVLW  0A
2692:  BTFSS  F9E.4
2694:  BRA    2692
2696:  MOVWF  FAD
....................          } 
2698:  BRA    26A6
....................          else { //fail, no transmit buffer was open 
....................             printf("\r\nFAIL on PUTD\r\n"); 
269A:  MOVLW  90
269C:  MOVWF  FF6
269E:  MOVLW  04
26A0:  MOVWF  FF7
26A2:  CALL   04A2
26A6:  MOVLB  F
....................          
....................          } 
....................          
....................       } 
....................     
....................        
....................      delay_ms(500);  
26A8:  MOVLW  02
26AA:  MOVWF  52
26AC:  MOVLW  FA
26AE:  MOVLB  0
26B0:  MOVWF  x71
26B2:  CALL   04C4
26B6:  DECFSZ 52,F
26B8:  BRA    26BC
26BA:  BRA    26C0
26BC:  MOVLB  F
26BE:  BRA    26AC
26C0:  BRA    1F48
....................    } 
.................... } 
26C2:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0091   STVREN NOLVP BBSIZ2K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
